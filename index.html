<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lyruanna</title>
    <style>
        :root {
            --bg: #0a0a0f;
            --panel: #12121a;
            --panel-glass: rgba(18, 18, 26, 0.85);
            --accent: #00ff9d;
            --accent-dim: rgba(0, 255, 157, 0.2);
            --text: #eee;

            /* Difficulty Colors */
            --diff-beginner: #5ff;
            --diff-normal: #0f0;
            --diff-hyper: #fa0;
            --diff-another: #f00;
            --diff-legg: #f0f;

            /* Gauge Colors */
            --gauge-easy: #00ff00;
            --gauge-normal: #00aaff;
            --gauge-clear: #ff0055;
            --gauge-hard: #ff3333;
            --gauge-exhard: #ffaa00;
        }

        body {
            margin: 0;
            background: var(--bg);
            color: var(--text);
            font-family: 'Segoe UI', sans-serif;
            overflow: hidden;
            user-select: none;
        }

        #app {
            display: flex;
            width: 100vw;
            height: 100vh;
        }

        /* ========== SONG SELECT SCREEN ========== */
        #screen-select {
            display: flex;
            width: 100%;
            height: 100%;
            background: #000;
        }

        .select-bg {
            position: absolute;
            inset: 0;
            z-index: 0;
            background-size: cover;
            background-position: center;
            filter: blur(8px) brightness(0.3);
            transition: background-image 0.5s;
        }

        /* LEFT: Song Detail Panel */
        .song-detail-panel {
            flex: 1;
            position: relative;
            z-index: 1;
            display: flex;
            flex-direction: column;
            padding: 20px 30px;
        }

        .top-buttons {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }

        .icon-btn {
            width: 40px;
            height: 40px;
            background: rgba(30, 30, 40, 0.8);
            border: 1px solid #444;
            border-radius: 8px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            color: #aaa;
            transition: 0.2s;
        }

        .icon-btn:hover {
            background: var(--accent);
            color: #000;
            border-color: var(--accent);
        }

        .song-info-card {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: var(--panel-glass);
            backdrop-filter: blur(10px);
            border: 1px solid #333;
            border-radius: 12px;
            overflow: hidden;
        }

        .banner-area {
            height: 80px;
            background: linear-gradient(135deg, #222, #111);
            display: flex;
            align-items: center;
            justify-content: center;
            border-bottom: 1px solid #333;
        }

        .banner-area img {
            max-height: 100%;
            max-width: 100%;
            object-fit: contain;
        }

        .banner-placeholder {
            color: #444;
            font-size: 14px;
        }

        .stagefile-area {
            flex: 1;
            position: relative;
            background-size: cover;
            background-position: center;
            padding: 20px;
        }

        .stagefile-overlay {
            position: absolute;
            inset: 0;
            background: linear-gradient(to bottom, rgba(0, 0, 0, 0.7) 0%, rgba(0, 0, 0, 0.4) 50%, rgba(0, 0, 0, 0.8) 100%);
        }

        .song-meta {
            position: relative;
            z-index: 1;
            height: 100%;
            display: flex;
            flex-direction: column;
        }

        .song-title-main {
            font-size: 28px;
            font-weight: bold;
            margin-bottom: 4px;
            text-shadow: 2px 2px 8px rgba(0, 0, 0, 0.8);
        }

        .song-subtitle {
            font-size: 14px;
            color: #aaa;
            margin-bottom: 8px;
        }

        .song-artist-genre {
            font-size: 14px;
            color: #888;
            margin-bottom: 15px;
        }

        .song-stats {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px 20px;
            font-size: 13px;
            margin-bottom: 20px;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            background: rgba(0, 0, 0, 0.4);
            padding: 6px 10px;
            border-radius: 4px;
        }

        .stat-label {
            color: #888;
        }

        .stat-value {
            color: #fff;
            font-weight: bold;
            font-family: 'Consolas', monospace;
        }

        .difficulty-display {
            display: flex;
            align-items: center;
            gap: 15px;
            background: rgba(0, 0, 0, 0.5);
            padding: 12px 15px;
            border-radius: 6px;
            margin-bottom: 15px;
        }

        .diff-level {
            font-size: 36px;
            font-weight: 900;
            font-family: 'Consolas', monospace;
        }

        .diff-stars {
            font-size: 12px;
            letter-spacing: 1px;
        }

        .diff-tier {
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 2px;
            opacity: 0.8;
        }

        .song-markers {
            display: flex;
            gap: 8px;
            margin-bottom: 15px;
        }

        .marker {
            padding: 4px 10px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: bold;
            text-transform: uppercase;
        }

        .marker-ln {
            background: #f50;
            color: #fff;
        }

        .marker-ran {
            background: #05f;
            color: #fff;
        }

        .start-btn-area {
            margin-top: auto;
        }

        .btn-start-main {
            width: 100%;
            padding: 15px;
            background: linear-gradient(135deg, var(--accent), #00cc7a);
            border: none;
            border-radius: 8px;
            color: #000;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            transition: 0.2s;
            text-transform: uppercase;
            letter-spacing: 3px;
        }

        .btn-start-main:hover {
            transform: scale(1.02);
            box-shadow: 0 0 20px var(--accent-dim);
        }

        /* RIGHT: Song List */
        .song-list-panel {
            width: 350px;
            background: var(--panel);
            border-left: 1px solid #333;
            z-index: 1;
            display: flex;
            flex-direction: column;
        }

        .song-list-header {
            padding: 12px 15px;
            border-bottom: 1px solid #333;
            font-size: 12px;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 1px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .filter-buttons {
            display: flex;
            gap: 8px;
        }

        .filter-btn {
            background: rgba(30, 30, 40, 0.8);
            border: 1px solid #444;
            border-radius: 4px;
            padding: 4px 10px;
            font-size: 11px;
            color: #aaa;
            cursor: pointer;
            transition: 0.2s;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .filter-btn:hover {
            background: var(--accent);
            color: #000;
            border-color: var(--accent);
        }

        .filter-btn span {
            color: var(--accent);
            font-weight: bold;
        }

        .filter-btn:hover span {
            color: #000;
        }

        .song-list {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
        }

        .song-list::-webkit-scrollbar {
            width: 6px;
        }

        .song-list::-webkit-scrollbar-thumb {
            background: #444;
            border-radius: 3px;
        }

        .song-card {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px 15px;
            margin-bottom: 8px;
            background: rgba(30, 30, 40, 0.6);
            border-left: 3px solid #444;
            border-radius: 6px;
            cursor: pointer;
            transition: 0.2s;
        }

        .song-card:hover {
            background: rgba(50, 50, 60, 0.8);
            transform: translateX(-3px);
        }

        .song-card.active {
            border-color: var(--accent);
            background: linear-gradient(90deg, var(--accent-dim), transparent);
            box-shadow: 0 0 15px var(--accent-dim);
        }

        .song-card-lamp {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            flex-shrink: 0;
        }

        .song-card-content {
            flex: 1;
            min-width: 0;
        }

        .song-card-title {
            font-size: 14px;
            font-weight: bold;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            margin-bottom: 3px;
        }

        .song-card-artist {
            font-size: 11px;
            color: #888;
        }

        .song-card-info {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 4px;
            flex-shrink: 0;
        }

        .song-card-level {
            padding: 2px 8px;
            border-radius: 3px;
            font-size: 12px;
            font-weight: bold;
            min-width: 28px;
            text-align: center;
        }

        .song-card-keymode {
            font-size: 10px;
            color: #888;
            text-transform: uppercase;
        }

        /* ========== GAME SCREEN ========== */
        #screen-game {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            display: none;
            z-index: 100;
        }

        .game-bg {
            position: absolute;
            inset: 0;
            z-index: 0;
            background-size: cover;
            background-position: center;
            filter: blur(4px) brightness(0.25);
        }

        .game-bga {
            position: absolute;
            left: 30%;
            top: 10%;
            width: 40%;
            height: 60%;
            background: #111;
            border: 2px solid #333;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1;
        }

        .game-bga img,
        .game-bga video {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            position: relative;
            z-index: 2;
        }

        .hud {
            position: absolute;
            inset: 0;
            pointer-events: none;
            z-index: 10;
        }

        .hud-score {
            position: absolute;
            top: 20px;
            right: 20px;
            text-align: right;
        }

        .score-val {
            font-size: 48px;
            font-family: 'Consolas', monospace;
            font-weight: bold;
            text-shadow: 0 0 10px var(--accent);
        }

        .hud-combo {
            position: absolute;
            top: 25%;
            left: 35%;
            transform: translate(-50%, -50%);
            text-align: center;
            opacity: 0;
            transition: transform 0.1s;
        }

        .hud-combo.show {
            opacity: 1;
            transform: translate(-50%, -50%) scale(1.1);
        }

        .combo-num {
            font-size: 80px;
            font-weight: 900;
            line-height: 1;
            text-shadow: 0 0 20px var(--accent);
            color: #fff;
        }

        .combo-text {
            font-size: 14px;
            letter-spacing: 4px;
            color: var(--accent);
            font-weight: bold;
        }

        /* GAUGE BAR */
        .hud-gauge-container {
            position: absolute;
            bottom: 50px;
            left: 50%;
            transform: translateX(-50%);
            width: 400px;
            height: 16px;
            background: #333;
            border: 2px solid #555;
        }

        .gauge-fill {
            width: 0%;
            height: 100%;
            background: var(--gauge-normal);
            transition: width 0.1s linear, background 0.2s;
        }

        .gauge-fill.easy {
            background: var(--gauge-easy);
            box-shadow: 0 0 10px var(--gauge-easy);
        }

        .gauge-fill.normal {
            background: var(--gauge-normal);
        }

        .gauge-fill.cleared {
            background: var(--gauge-clear);
            box-shadow: 0 0 10px var(--gauge-clear);
        }

        .gauge-fill.hard {
            background: var(--gauge-hard);
            box-shadow: 0 0 10px var(--gauge-hard);
        }

        .gauge-fill.exhard {
            background: var(--gauge-exhard);
            box-shadow: 0 0 10px var(--gauge-exhard);
        }

        .gauge-marker {
            position: absolute;
            left: 80%;
            top: -5px;
            bottom: -5px;
            width: 2px;
            background: #fff;
            z-index: 2;
        }

        .gauge-val {
            position: absolute;
            right: -50px;
            top: -5px;
            font-family: monospace;
            font-weight: bold;
            color: white;
            font-size: 20px;
        }

        /* JUDGEMENT DISPLAY */
        .hud-judge {
            position: absolute;
            top: 50%;
            left: 15%;
            transform: translate(-50%, -50%);
            text-align: center;
            font-weight: bold;
            font-family: sans-serif;
            text-shadow: 0 0 10px #000;
            opacity: 0;
            transition: opacity 0.1s;
        }

        .hud-judge.show {
            opacity: 1;
            animation: judgePop 0.1s;
        }

        .judge-text {
            font-size: 32px;
            letter-spacing: 2px;
        }

        .judge-diff {
            font-size: 14px;
            margin-top: 5px;
            color: #aaa;
        }

        .pgreat {
            color: #aaaaff;
            text-shadow: 0 0 10px #aaaaff;
        }

        .great {
            color: #00ff00;
        }

        .good {
            color: #ffff00;
        }

        .bad {
            color: #ff5500;
        }

        .poor {
            color: #ff0000;
        }

        @keyframes judgePop {
            0% {
                transform: translate(-50%, -40%);
            }

            100% {
                transform: translate(-50%, -50%);
            }
        }

        /* JUDGEMENT TALLY */
        .hud-tally {
            position: absolute;
            top: 100px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px 20px;
            border: 1px solid #333;
            border-radius: 8px;
            font-family: 'Consolas', monospace;
        }

        .hud-tally.hidden {
            display: none;
        }

        .tally-row {
            display: flex;
            justify-content: space-between;
            gap: 25px;
            font-size: 13px;
            margin: 3px 0;
        }

        .tally-row.pgreat .tally-label {
            color: #aaf;
        }

        .tally-row.great .tally-label {
            color: #0f0;
        }

        .tally-row.good .tally-label {
            color: #ff0;
        }

        .tally-row.bad .tally-label {
            color: #f50;
        }

        .tally-row.poor .tally-label {
            color: #f00;
        }

        .tally-row.fast .tally-label {
            color: #f88;
        }

        .tally-row.slow .tally-label {
            color: #88f;
        }

        .tally-row.cb .tally-label {
            color: #888;
        }

        .tally-value {
            color: #fff;
            font-weight: bold;
            min-width: 40px;
            text-align: right;
        }

        .tally-divider {
            border: none;
            border-top: 1px solid #444;
            margin: 8px 0;
        }

        /* LANE COVERS */
        .lane-cover-top,
        .lane-cover-bottom {
            position: absolute;
            left: 0;
            width: 30%;
            background: #000;
            z-index: 5;
            pointer-events: none;
        }

        .lane-cover-top {
            top: 0;
        }

        .lane-cover-bottom {
            bottom: 0;
        }

        /* ========== MODALS ========== */
        .modal {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.9);
            z-index: 200;
            display: none;
            justify-content: center;
            align-items: center;
        }

        .modal.open {
            display: flex;
        }

        .modal-box {
            background: #1a1a1a;
            padding: 30px;
            border: 1px solid #444;
            max-width: 700px;
            width: 90%;
            border-radius: 12px;
            max-height: 80vh;
            overflow-y: auto;
        }

        .modal-header {
            font-size: 20px;
            font-weight: bold;
            margin-bottom: 20px;
            color: var(--accent);
        }

        .modal-section {
            margin-bottom: 25px;
        }

        .modal-section-title {
            font-size: 12px;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 10px;
            border-bottom: 1px solid #333;
            padding-bottom: 5px;
        }

        .modal-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
        }

        .key-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            background: #252525;
            padding: 5px 10px;
            border-radius: 4px;
        }

        .key-btn {
            background: #333;
            border: 1px solid #555;
            color: #fff;
            padding: 4px 10px;
            cursor: pointer;
            min-width: 80px;
            border-radius: 4px;
        }

        .key-btn.listening {
            background: var(--accent);
            color: #000;
        }

        .option-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
            padding: 8px 12px;
            background: #222;
            border-radius: 6px;
        }

        .option-label {
            font-size: 13px;
            color: #ccc;
        }

        .option-control {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .option-value {
            font-family: 'Consolas', monospace;
            font-weight: bold;
            min-width: 50px;
            text-align: center;
            color: var(--accent);
        }

        input[type="range"] {
            width: 120px;
            accent-color: var(--accent);
        }

        select {
            background: #333;
            color: #fff;
            border: 1px solid #555;
            padding: 6px 10px;
            border-radius: 4px;
            cursor: pointer;
        }

        input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--accent);
            cursor: pointer;
        }

        .btn {
            display: inline-block;
            background: #333;
            border: 1px solid #555;
            color: #fff;
            padding: 10px 20px;
            cursor: pointer;
            border-radius: 6px;
            transition: 0.2s;
            text-align: center;
        }

        .btn:hover {
            border-color: var(--accent);
            color: var(--accent);
        }

        .btn-primary {
            background: var(--accent);
            color: #000;
            border: none;
            font-weight: bold;
        }

        .btn-primary:hover {
            background: #fff;
        }

        .modal-footer {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            margin-top: 20px;
        }

        .hidden {
            display: none !important;
        }

        /* CUSTOM TITLEBAR */
        .titlebar {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 32px;
            background: #0a0a0a;
            display: flex;
            align-items: center;
            justify-content: space-between;
            -webkit-app-region: drag;
            z-index: 9999;
            border-bottom: 1px solid #222;
        }

        /* ========== RESULTS SCREEN ========== */
        #screen-results {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(10, 10, 15, 0.98);
            display: none;
            z-index: 300;
            padding: 50px;
            box-sizing: border-box;
            color: #eee;
            flex-direction: column;
        }

        .results-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-end;
            margin-bottom: 30px;
            border-bottom: 2px solid #333;
            padding-bottom: 20px;
        }

        .results-title-area h1 {
            margin: 0;
            font-size: 48px;
            color: var(--accent);
            text-transform: uppercase;
            letter-spacing: 4px;
        }

        .results-rank-area {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .rank-letter {
            font-size: 120px;
            font-weight: 900;
            line-height: 1;
            text-shadow: 0 0 30px var(--accent);
        }

        .rank-next {
            font-size: 14px;
            color: #888;
            margin-top: 10px;
        }

        .results-main {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 40px;
            flex: 1;
        }

        .results-left {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .results-right {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .results-card {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid #333;
            border-radius: 12px;
            padding: 20px;
        }

        .card-title {
            font-size: 14px;
            color: #888;
            text-transform: uppercase;
            margin-bottom: 15px;
            border-bottom: 1px solid #222;
            padding-bottom: 8px;
        }

        .results-tally-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px 30px;
        }

        .res-tally-row {
            display: flex;
            justify-content: space-between;
            font-size: 18px;
        }

        .res-tally-label {
            font-weight: bold;
        }

        .res-tally-val {
            font-family: 'Consolas', monospace;
        }

        .res-pg {
            color: #aaf;
        }

        .res-gr {
            color: #0f0;
        }

        .res-gd {
            color: #ff0;
        }

        .res-bd {
            color: #f50;
        }

        .res-pr {
            color: #f00;
        }

        .graph-container {
            position: relative;
            width: 100%;
            height: 180px;
            background: #000;
            border: 1px solid #444;
            margin-top: 10px;
        }

        canvas.results-graph {
            width: 100%;
            height: 100%;
        }

        .results-footer {
            margin-top: 30px;
            text-align: center;
            font-size: 14px;
            color: #666;
            animation: blink 1.5s infinite;
        }

        /* LAMP STYLES */
        .lamp {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
        }

        .lamp.no-play {
            background: #333;
        }

        .lamp.failed {
            background: #555;
        }

        .lamp.assist {
            background: #4af;
            box-shadow: 0 0 8px #4af;
        }

        .lamp.easy {
            background: #5f5;
            box-shadow: 0 0 8px #5f5;
        }

        .lamp.clear {
            background: #8f0;
            box-shadow: 0 0 8px #8f0;
        }

        .lamp.hard {
            background: #f44;
            box-shadow: 0 0 8px #f44;
        }

        .lamp.ex-hard {
            background: #f0f;
            box-shadow: 0 0 8px #f0f;
        }

        .lamp.fc {
            background: #ff0;
            box-shadow: 0 0 8px #ff0;
        }

        .lamp.perfect {
            background: #0ff;
            box-shadow: 0 0 10px #0ff;
        }

        .lamp.max {
            background: #fff;
            box-shadow: 0 0 15px #fff;
            animation: rainbow 2s infinite linear;
        }

        @keyframes rainbow {
            0% {
                filter: hue-rotate(0deg);
                background: #f00;
            }

            100% {
                filter: hue-rotate(360deg);
                background: #f00;
            }
        }

        .song-card {
            display: flex;
            align-items: center;
            padding: 12px 15px;
            margin-bottom: 8px;
            background: rgba(30, 30, 40, 0.6);
            border-left: 4px solid transparent;
            cursor: pointer;
            transition: 0.2s;
            border-radius: 4px;
        }

        .song-card.active {
            background: rgba(0, 255, 157, 0.15);
            border-left-color: var(--accent);
        }

        .song-card-content {
            flex: 1;
        }

        .song-card-lamp {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            margin-right: 12px;
        }

        @keyframes blink {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.3;
            }
        }

        .titlebar-title {
            padding-left: 12px;
            font-size: 12px;
            font-weight: 600;
            color: var(--accent);
            letter-spacing: 1px;
        }

        .titlebar-controls {
            display: flex;
            height: 100%;
            -webkit-app-region: no-drag;
        }

        .titlebar-btn {
            width: 46px;
            height: 100%;
            border: none;
            background: transparent;
            color: #888;
            font-size: 16px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.15s, color 0.15s;
        }

        .titlebar-btn:hover {
            background: #333;
            color: #fff;
        }

        .titlebar-btn.close:hover {
            background: #e81123;
            color: #fff;
        }

        .titlebar-btn svg {
            width: 12px;
            height: 12px;
            fill: currentColor;
        }

        /* Adjust app content to account for titlebar */
        #app {
            padding-top: 32px;
            box-sizing: border-box;
        }

        #screen-game {
            top: 32px;
            height: calc(100% - 32px);
        }

        /* LIBRARY FOLDERS MODAL */
        .folder-list {
            max-height: 250px;
            overflow-y: auto;
            background: #222;
            border-radius: 6px;
            margin-bottom: 15px;
        }

        .folder-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 15px;
            border-bottom: 1px solid #333;
        }

        .folder-item:last-child {
            border-bottom: none;
        }

        .folder-path {
            font-size: 13px;
            color: #ccc;
            word-break: break-all;
            flex: 1;
            margin-right: 15px;
        }

        .folder-remove-btn {
            background: #f44;
            border: none;
            color: #fff;
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: 0.2s;
        }

        .folder-remove-btn:hover {
            background: #f66;
        }

        .no-folders {
            text-align: center;
            color: #666;
            padding: 30px;
            font-size: 14px;
        }

        .folder-actions {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        /* PROGRESS BAR */
        .progress-section {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid #333;
        }

        .progress-bar-container {
            height: 20px;
            background: #333;
            border-radius: 10px;
            overflow: hidden;
            margin-top: 10px;
        }

        .progress-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--accent), #00cc7a);
            width: 0%;
            transition: width 0.15s ease-out;
        }

        .progress-status {
            font-size: 13px;
            color: #aaa;
            margin-top: 8px;
        }

        /* IIDX STYLE OPTIONS */
        .modal-iidx {
            background: rgba(0, 0, 0, 0);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s ease-out, background 0.2s ease-out;
        }

        .modal-iidx.open {
            opacity: 1;
            pointer-events: auto;
            background: rgba(0, 0, 0, 0.85);
        }

        .iidx-options-container {
            background: #111;
            border: 2px solid #0ff;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.4);
            width: 1000px;
            min-height: 650px;
            padding: 20px;
            display: flex;
            flex-direction: column;
            font-family: 'Outfit', sans-serif;
            color: #fff;
            transform: translateY(20px) scale(0.95);
            transition: transform 0.2s ease-out;
        }

        .modal-iidx.open .iidx-options-container {
            transform: translateY(0) scale(1);
        }

        .iidx-options-header {
            background: #0ff;
            color: #000;
            padding: 8px 15px;
            font-weight: 800;
            font-size: 1.2rem;
            text-align: left;
            letter-spacing: 2px;
            margin: -20px -20px 15px -20px;
        }

        /* Keyboard Guide */
        .iidx-keyboard-guide {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 6px;
            padding: 15px 0 25px 0;
            position: relative;
        }

        .iidx-key-row {
            display: flex;
            justify-content: center;
            gap: 20px;
        }

        .iidx-key {
            width: 36px;
            height: 72px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1rem;
            font-weight: 800;
            border-radius: 4px;
            cursor: default;
        }

        .iidx-key-white {
            background: #eee;
            color: #111;
            border: 1px solid #aaa;
        }

        .iidx-key-black {
            background: #222;
            color: #fff;
            border: 1px solid #555;
        }

        /* Wiring Container (SVG overlay) */
        .iidx-wiring-svg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .iidx-wiring-svg line,
        .iidx-wiring-svg polyline {
            stroke: #0ff;
            stroke-width: 1.5;
            fill: none;
            opacity: 0.6;
        }

        .iidx-options-grid {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 10px;
            padding: 15px;
            min-height: 300px;
        }

        .iidx-section {
            display: flex;
            flex-direction: column;
            gap: 8px;
            border-left: 1px solid #333;
            padding-left: 10px;
        }

        .iidx-section-name {
            color: #0ff;
            font-size: 0.75rem;
            font-weight: 800;
            margin-bottom: 5px;
            text-transform: uppercase;
            border-bottom: 1px solid #0ff;
            padding-bottom: 2px;
        }

        .iidx-opt-list {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .iidx-opt-list div {
            font-size: 0.8rem;
            padding: 4px 8px;
            color: #888;
            cursor: pointer;
            text-transform: uppercase;
            transition: 0.1s;
        }

        .iidx-opt-list div.selected {
            background: #0ff;
            color: #000;
            font-weight: 800;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
        }

        .iidx-opt-group {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .iidx-opt-subname {
            font-size: 0.65rem;
            color: #555;
            font-weight: 700;
            text-transform: uppercase;
        }

        .iidx-hs-display {
            background: #222;
            padding: 10px;
            border: 1px solid #444;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 5px;
        }

        .iidx-hs-val {
            font-size: 1.5rem;
            font-weight: 900;
            color: #ff0;
            text-shadow: 0 0 10px rgba(255, 255, 0, 0.5);
        }

        .iidx-hs-fix {
            font-size: 0.7rem;
            color: #aaa;
        }

        .iidx-range-row span:first-child {
            font-size: 0.7rem;
            color: #888;
            text-transform: uppercase;
        }

        .iidx-range-row span:last-child {
            font-size: 1.1rem;
            color: #ff0;
            font-weight: 700;
            text-align: right;
        }

        .iidx-options-footer {
            padding: 15px;
            border-top: 1px solid #333;
            text-align: right;
        }

        .iidx-btn {
            background: #ff0;
            color: #000;
            border: none;
            padding: 10px 30px;
            font-weight: 800;
            cursor: pointer;
            transition: background 0.2s;
        }

        .iidx-btn:hover {
            background: #cc0;
        }

        /* ========== DECIDE SCREEN ========== */
        #screen-decide {
            position: fixed;
            top: 32px;
            left: 0;
            width: 100%;
            height: calc(100% - 32px);
            background: #000;
            display: none;
            z-index: 500;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            transition: opacity 1s ease-out;
        }

        #screen-decide.fade-out {
            opacity: 0;
        }

        .decide-content {
            padding: 40px;
            border-top: 2px solid var(--accent);
            border-bottom: 2px solid var(--accent);
            background: rgba(0, 255, 157, 0.05);
            width: 100%;
        }

        .decide-title {
            font-size: 64px;
            font-weight: 900;
            color: var(--accent);
            margin-bottom: 20px;
            letter-spacing: 5px;
            text-transform: uppercase;
            text-shadow: 0 0 20px var(--accent-dim);
        }

        .decide-artist {
            font-size: 24px;
            color: #888;
            letter-spacing: 2px;
        }

        /* Folder styles */
        .song-card.folder {
            border-left-color: #fcc419 !important;
            background: rgba(252, 196, 25, 0.05);
        }
        .song-card.folder:hover {
            background: rgba(252, 196, 25, 0.1);
        }
        .song-card.folder .song-card-lamp {
            background: #fcc419;
            box-shadow: 0 0 8px #fcc419;
        }

        /* Course / Class items */
        #btn-autoplay, #btn-replay {
            font-size: 11px;
            padding: 6px 10px;
            font-weight: 800;
            letter-spacing: 1px;
            color: #fff;
            border-color: #555;
            text-shadow: 0 0 5px rgba(255,255,255,0.2);
        }
        #btn-autoplay:hover {
            background: rgba(0, 255, 255, 0.1);
            border-color: #0ff;
            color: #0ff;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.2);
        }
        #btn-replay:hover {
            background: rgba(255, 255, 0, 0.1);
            border-color: #ff0;
            color: #ff0;
            box-shadow: 0 0 10px rgba(255, 255, 0, 0.2);
        }

        .song-card.focused {
            border-color: #fff !important;
            background: rgba(255, 255, 255, 0.15) !important;
            box-shadow: inset 0 0 15px rgba(255, 255, 255, 0.1);
            transform: translateX(5px);
        }

        .song-card.folder-class {
            border-left-color: #0ff !important;
            background: rgba(0, 255, 255, 0.05);
        }
        .song-card.folder-class:hover, .song-card.folder-class.focused {
            background: rgba(0, 255, 255, 0.1);
        }
        .song-card.folder-class .song-card-lamp {
            background: #0ff;
            box-shadow: 0 0 8px #0ff;
        }
    </style>
</head>

<body>

    <!-- CUSTOM TITLEBAR (Desktop Only) -->
    <div class="titlebar" id="titlebar" style="display:none;">
        <span class="titlebar-title">LYRUANNA - BMS Player</span>
        <div class="titlebar-controls">
            <button class="titlebar-btn" id="btn-minimize" title="Minimize">
                <svg viewBox="0 0 12 12">
                    <rect y="5" width="12" height="2" />
                </svg>
            </button>
            <button class="titlebar-btn" id="btn-maximize" title="Maximize">
                <svg viewBox="0 0 12 12">
                    <rect x="1" y="1" width="10" height="10" fill="none" stroke="currentColor" stroke-width="2" />
                </svg>
            </button>
            <button class="titlebar-btn close" id="btn-close" title="Close">
                <svg viewBox="0 0 12 12">
                    <path d="M1 1l10 10M11 1L1 11" stroke="currentColor" stroke-width="2" />
                </svg>
            </button>
        </div>
    </div>

    <div id="app">
        <!-- SELECT SCREEN -->
        <div id="screen-select">
            <div class="select-bg" id="select-bg"></div>

            <!-- Left: Song Detail Panel -->
            <div class="song-detail-panel">
                <div class="top-buttons">
                    <button class="icon-btn" id="btn-settings" title="Settings">‚öôÔ∏è</button>
                    <button class="icon-btn" id="btn-options" title="Player Options">üéÆ</button>
                    <button class="icon-btn" id="btn-scan-lib" title="Library Folders">üìÅ</button>
                    <input type="file" id="file-picker" webkitdirectory directory multiple style="display:none">
                </div>

                <div class="song-info-card" id="song-info-card">
                    <div class="banner-area" id="banner-area">
                        <span class="banner-placeholder">No song selected</span>
                    </div>
                    <div class="stagefile-area" id="stagefile-area">
                        <div class="stagefile-overlay"></div>
                        <div class="song-meta">
                            <div class="song-title-main" id="song-title-main">Select a song</div>
                            <div class="song-subtitle" id="song-subtitle"></div>
                            <div class="song-artist-genre" id="song-artist-genre"></div>

                            <div class="difficulty-display" id="difficulty-display" style="display:none;">
                                <div>
                                    <div class="diff-level" id="diff-level">--</div>
                                    <div class="diff-tier" id="diff-tier">UNKNOWN</div>
                                </div>
                                <div class="diff-stars" id="diff-stars"></div>
                            </div>

                            <div class="song-stats" id="song-stats" style="display:none;">
                                <div class="stat-row"><span class="stat-label">BPM</span><span class="stat-value"
                                        id="stat-bpm">--</span></div>
                                <div class="stat-row"><span class="stat-label">Notes</span><span class="stat-value"
                                        id="stat-notes">--</span></div>
                                <div class="stat-row"><span class="stat-label">Start NPS</span><span class="stat-value"
                                        id="stat-nps-start">--</span></div>
                                <div class="stat-row"><span class="stat-label">Avg NPS</span><span class="stat-value"
                                        id="stat-nps-avg">--</span></div>
                                <div class="stat-row"><span class="stat-label">Max NPS</span><span class="stat-value"
                                        id="stat-nps-max">--</span></div>
                                <div class="stat-row"><span class="stat-label">Rank</span><span class="stat-value"
                                        id="stat-rank">--</span></div>
                            </div>

                            <div class="song-markers" id="song-markers"></div>

                            <div class="start-btn-area">
                                <button class="btn-start-main" id="btn-start" disabled>START</button>
                                <div style="display:flex; gap:10px; margin-top:10px;">
                                    <button class="btn" id="btn-autoplay" style="flex:1;">AUTOPLAY</button>
                                    <button class="btn" id="btn-replay" style="flex:1;">REPLAY</button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Right: Song List -->
            <div class="song-list-panel">
                <div class="song-list-header">
                    <span id="song-count">0</span> Songs
                    <div class="filter-buttons">
                        <button class="filter-btn" id="btn-diff-filter" title="Difficulty Filter">DIFF: <span id="diff-filter">ALL</span></button>
                        <button class="filter-btn" id="btn-km-filter" title="Key Mode Filter">MODE: <span id="km-filter">ALL</span></button>
                        <button class="filter-btn" id="btn-sort" title="Sort By">SORT: <span id="sort-mode">DEFAULT</span></button>
                    </div>
                </div>
                <div class="song-list" id="song-list"></div>
            </div>
        </div>

        <!-- GAME SCREEN -->
        <div id="screen-game">
            <div class="game-bg" id="game-bg"></div>
            <div class="game-bga" id="game-bga">
                <img id="bga-img" style="display:none;">
                <video id="bga-video" style="display:none;" muted></video>
            </div>
            <div class="lane-cover-top" id="lane-cover-top" style="height:0;"></div>
            <div class="lane-cover-bottom" id="lane-cover-bottom" style="height:0;"></div>
            <canvas id="game-canvas"></canvas>
            <div class="hud">
                <div class="hud-score">
                    <div style="font-size:12px; color:#888;">EX SCORE</div>
                    <div class="score-val" id="hud-score">0</div>
                </div>

                <div class="hud-combo" id="hud-combo-box">
                    <div class="combo-num" id="hud-combo">0</div>
                    <div class="combo-text">COMBO</div>
                </div>

                <div class="hud-judge" id="hud-judge-box">
                    <div class="judge-text" id="judge-text">PGREAT</div>
                    <div class="judge-diff" id="judge-diff">+0ms</div>
                </div>

                <div class="hud-gauge-container">
                    <div class="gauge-marker"></div>
                    <div class="gauge-fill" id="gauge-bar"></div>
                    <div class="gauge-val" id="gauge-val">20%</div>
                </div>

                <div class="hud-tally" id="hud-tally">
                    <div class="tally-row pgreat"><span class="tally-label">PGREAT</span><span class="tally-value"
                            id="tally-pg">0</span></div>
                    <div class="tally-row great"><span class="tally-label">GREAT</span><span class="tally-value"
                            id="tally-gr">0</span></div>
                    <div class="tally-row good"><span class="tally-label">GOOD</span><span class="tally-value"
                            id="tally-gd">0</span></div>
                    <div class="tally-row bad"><span class="tally-label">BAD</span><span class="tally-value"
                            id="tally-bd">0</span></div>
                    <div class="tally-row poor"><span class="tally-label">POOR</span><span class="tally-value"
                            id="tally-pr">0</span></div>
                    <hr class="tally-divider">
                    <div class="tally-row fast"><span class="tally-label">FAST</span><span class="tally-value"
                            id="tally-fast">0</span></div>
                    <div class="tally-row slow"><span class="tally-label">SLOW</span><span class="tally-value"
                            id="tally-slow">0</span></div>
                    <div class="tally-row cb"><span class="tally-label">C.BREAK</span><span class="tally-value"
                            id="tally-cb">0</span></div>
                </div>

                <div style="position:absolute; bottom:20px; width:100%; text-align:center; font-size:12px; color:#555;">
                    [ESCAPE] to Exit
                </div>
            </div>
        </div>

        <!-- RESULTS SCREEN -->
        <div id="screen-results">
            <div class="results-header">
                <div class="results-title-area">
                    <h1 id="res-status">CLEARED</h1>
                    <div style="display: flex; align-items: center; gap: 10px; margin-top: 5px;">
                        <span id="res-lamp" class="lamp"></span>
                        <span id="res-lamp-text"
                            style="font-weight: bold; font-size: 18px; text-transform: uppercase;">--</span>
                    </div>
                    <div id="res-song-title" style="font-size: 20px; color: #888; margin-top: 10px;">Song Title</div>
                </div>
                <div class="results-rank-area">
                    <div class="rank-letter" id="res-rank">AAA</div>
                    <div class="rank-next" id="res-rank-next">NEXT RANK: +0</div>
                </div>
            </div>

            <div class="results-main">
                <div class="results-left">
                    <div class="results-card">
                        <div class="card-title">JUDGEMENT</div>
                        <div class="results-tally-grid">
                            <div class="res-tally-row res-pg"><span class="res-tally-label">PGREAT</span><span
                                    class="res-tally-val" id="res-pg">0</span></div>
                            <div class="res-tally-row res-gr"><span class="res-tally-label">GREAT</span><span
                                    class="res-tally-val" id="res-gr">0</span></div>
                            <div class="res-tally-row res-gd"><span class="res-tally-label">GOOD</span><span
                                    class="res-tally-val" id="res-gd">0</span></div>
                            <div class="res-tally-row res-bd"><span class="res-tally-label">BAD</span><span
                                    class="res-tally-val" id="res-bd">0</span></div>
                            <div class="res-tally-row res-pr"><span class="res-tally-label">POOR</span><span
                                    class="res-tally-val" id="res-pr">0</span></div>
                            <div style="border-left: 1px solid #333; margin-left: 15px; padding-left: 15px;">
                                <div class="res-tally-row"><span class="res-tally-label"
                                        style="color:#55c">FAST</span><span class="res-tally-val" id="res-fast">0</span>
                                </div>
                                <div class="res-tally-row"><span class="res-tally-label"
                                        style="color:#c55">SLOW</span><span class="res-tally-val" id="res-slow">0</span>
                                </div>
                                <div class="res-tally-row"><span class="res-tally-label" style="color:#888">MAX
                                        COMBO</span><span class="res-tally-val" id="res-max-combo">0</span></div>
                            </div>
                        </div>
                    </div>
                    <div class="results-card">
                        <div class="card-title">SCORE</div>
                        <div style="display: flex; justify-content: space-between; align-items: flex-end;">
                            <div>
                                <div style="font-size: 14px; color: #888;">EX SCORE</div>
                                <div style="font-size: 36px; font-weight: bold; color: var(--accent);"
                                    id="res-ex-score">0</div>
                            </div>
                            <div style="text-align: right;">
                                <div style="font-size: 14px; color: #888;">PERCENTAGE</div>
                                <div style="font-size: 24px;" id="res-percent">0.00%</div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="results-right">
                    <div class="results-card">
                        <div class="card-title">GROOVE GAUGE</div>
                        <div class="graph-container">
                            <canvas id="graph-gauge" class="results-graph"></canvas>
                        </div>
                    </div>
                    <div class="results-card">
                        <div class="card-title">SCORE PROGRESS</div>
                        <div class="graph-container">
                            <canvas id="graph-score" class="results-graph"></canvas>
                        </div>
                    </div>
                </div>
            </div>

            <div class="results-footer">
                PRESS ANY KEY TO RETURN
            </div>
        </div>

        <!-- SETTINGS MODAL -->
        <div id="modal-settings" class="modal">
            <div class="modal-box">
                <div class="modal-header">Settings</div>

                <div class="modal-section">
                    <div class="modal-section-title">Display</div>
                    <div class="option-row">
                        <span class="option-label">Show Judgement Tally</span>
                        <input type="checkbox" id="opt-show-tally" checked>
                    </div>
                </div>

                <div class="modal-section">
                    <div class="modal-section-title">Key Bindings</div>
                    <div class="modal-grid">
                        <div id="col-p1">
                            <h4 style="margin:0 0 10px 0; color:#888;">Player 1</h4>
                        </div>
                        <div id="col-p2">
                            <h4 style="margin:0 0 10px 0; color:#888;">Player 2</h4>
                        </div>
                    </div>
                </div>

                <div class="modal-footer">
                    <button class="btn btn-primary" id="btn-save-settings">Save & Close</button>
                </div>
            </div>
        </div>

        <!-- PLAYER OPTIONS MODAL (IIDX-STYLE) -->
        <div id="modal-options" class="modal modal-iidx">
            <div class="iidx-options-container">
                <div class="iidx-options-header">PLAYER OPTIONS</div>

                <!-- Keyboard Guide -->
                <div class="iidx-keyboard-guide" id="iidx-keyboard-guide">
                    <div class="iidx-key-row">
                        <div class="iidx-key iidx-key-black" data-key="2">2</div>
                        <div class="iidx-key iidx-key-black" data-key="4">4</div>
                        <div class="iidx-key iidx-key-black" data-key="6">6</div>
                    </div>
                    <div class="iidx-key-row">
                        <div class="iidx-key iidx-key-white" data-key="1">1</div>
                        <div class="iidx-key iidx-key-white" data-key="3">3</div>
                        <div class="iidx-key iidx-key-white" data-key="5">5</div>
                        <div class="iidx-key iidx-key-white" data-key="7">7</div>
                    </div>
                    <svg class="iidx-wiring-svg" id="iidx-wiring-svg"></svg>
                </div>

                <div class="iidx-options-grid">
                    <!-- COLUMN 1: KEY MODE (KEY 1) -->
                    <div class="iidx-section" id="sec-mode">
                        <div class="iidx-section-name">[1] MODE</div>
                        <div class="iidx-opt-list" id="list-mode">
                            <div data-val="ALL">ALL</div>
                            <div data-val="Âçï">SINGLE</div>
                            <div data-val="5">5KEY</div>
                            <div data-val="7">7KEY</div>
                            <div data-val="9">9KEY</div>
                            <div data-val="Âèå">DOUBLE</div>
                            <div data-val="10">10KEY</div>
                            <div data-val="14">14KEY</div>
                        </div>
                    </div>

                    <!-- COLUMN 2: STYLE (KEY 2) -->
                    <div class="iidx-section" id="sec-style">
                        <div class="iidx-section-name">[2] STYLE</div>
                        <div class="iidx-opt-list" id="list-modifier">
                            <div data-val="OFF">OFF</div>
                            <div data-val="MIRROR">MIRROR</div>
                            <div data-val="RANDOM">RANDOM</div>
                            <div data-val="S-RANDOM">S-RANDOM</div>
                            <div data-val="H-RANDOM">H-RANDOM</div>
                            <div data-val="R-RANDOM">R-RANDOM</div>
                            <div data-val="ALL-SCRATCH">ALL-SCRATCH</div>
                        </div>
                    </div>

                    <!-- COLUMN 3: BATTLE (KEY 3) -->
                    <div class="iidx-section" id="sec-battle">
                        <div class="iidx-section-name">[3] BATTLE</div>
                        <div class="iidx-opt-list">
                            <div data-val="OFF" class="selected">OFF</div>
                            <div data-val="ON" style="color:#444;">(COMING SOON)</div>
                        </div>
                    </div>

                    <!-- COLUMN 4: GAUGE (KEY 4) -->
                    <div class="iidx-section" id="sec-gauge">
                        <div class="iidx-section-name">[4] GAUGE</div>
                        <div class="iidx-opt-list" id="list-gauge">
                            <div data-val="GROOVE">GROOVE</div>
                            <div data-val="EASY">EASY</div>
                            <div data-val="HARD">HARD</div>
                            <div data-val="EXHARD">EX-HARD</div>
                            <div data-val="ASSIST">ASSIST EASY</div>
                        </div>
                    </div>

                    <!-- COLUMN 5: ASSIST/RANGE (KEY 6, 6+7) -->
                    <div class="iidx-section" id="sec-assist">
                        <div class="iidx-section-name">[6] AS / [6+7] RAN</div>
                        <div class="iidx-opt-group" id="group-assist">
                            <div class="iidx-opt-subname">ASSIST</div>
                            <div class="iidx-opt-list" id="list-assist">
                                <div data-val="OFF">OFF</div>
                                <div data-val="A-SCR">AUTO-SCRATCH</div>
                                <div data-val="EX-JUDGE">EXTEND JUDGE</div>
                                <div data-val="BOTH">A-SCR + EX-JDG</div>
                            </div>
                        </div>
                        <div class="iidx-opt-group" id="group-range"
                            style="border-top: 1px solid #333; margin-top:5px; padding-top:5px;">
                            <div class="iidx-opt-subname">RANGE</div>
                            <div class="iidx-opt-list" id="list-range">
                                <div data-val="OFF">OFF</div>
                                <div data-val="SUDDEN+">SUDDEN+</div>
                                <div data-val="LIFT">LIFT</div>
                                <div data-val="LIFT-SUD+">LIFT & SUD+</div>
                            </div>
                        </div>
                    </div>

                    <!-- COLUMN 6: HI-SPEED (KEY 5/7, 5+7) -->
                    <div class="iidx-section" id="sec-hispeed">
                        <div class="iidx-section-name">[5/7] HS / [5+7] FIX</div>
                        <div class="iidx-hs-display">
                            <div class="iidx-hs-val" id="opt-hispeed-val">4.0</div>
                            <div class="iidx-hs-fix" id="opt-hsfix-val">FIX: NONE</div>
                        </div>
                        <div class="iidx-opt-group" id="group-hsfix"
                            style="border-top: 1px solid #333; margin-top:5px; padding-top:5px;">
                            <div class="iidx-opt-subname">HS FIX (5+7)</div>
                            <div class="iidx-opt-list" id="list-hsfix">
                                <div data-val="NONE">NONE</div>
                                <div data-val="MIN">MIN BPM</div>
                                <div data-val="MAX">MAX BPM</div>
                                <div data-val="AVG">AVG BPM</div>
                                <div data-val="CONSTANT">CONSTANT</div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="iidx-options-footer">
                    <button class="iidx-btn" id="btn-save-options">EXIT [START]</button>
                </div>
            </div>
        </div>

        <!-- LIBRARY FOLDERS MODAL -->
        <div id="modal-folders" class="modal">
            <div class="modal-box">
                <div class="modal-header">Library Folders</div>

                <div class="modal-section">
                    <div class="modal-section-title">Song Directories</div>
                    <div class="folder-list" id="folder-list">
                        <div class="no-folders">No folders added yet</div>
                    </div>
                    <div class="folder-actions">
                        <button class="btn btn-primary" id="btn-add-folder">üìÅ Add Folder</button>
                        <button class="btn" id="btn-rescan-all">üîÑ Rescan All</button>
                    </div>
                </div>

                <div class="progress-section" id="progress-section" style="display: none;">
                    <div class="modal-section-title">Scan Progress</div>
                    <div class="progress-bar-container">
                        <div class="progress-bar-fill" id="progress-bar-fill"></div>
                    </div>
                    <div class="progress-status" id="progress-status">Ready</div>
                </div>

                <div class="modal-footer">
                    <button class="btn btn-primary" id="btn-close-folders">Close</button>
                </div>
            </div>
        </div>

        <!-- DECIDE SCREEN -->
        <div id="screen-decide">
            <div class="decide-content">
                <div class="decide-title" id="decide-title">SONG TITLE</div>
                <div class="decide-artist" id="decide-artist">ARTIST NAME</div>
            </div>
        </div>
    </div>

    <script>
        /**
         * ============================================================================
         * ENGINE CORE
         * ============================================================================
         */
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

        // ----------------------------------------------------------------------------
        // CONSTANTS & HELPERS
        // ----------------------------------------------------------------------------
        const LAMPS = {
            NO_PLAY: { id: 0, name: 'NO PLAY', class: 'no-play' },
            FAILED: { id: 1, name: 'FAILED', class: 'failed' },
            ASSIST: { id: 2, name: 'ASSIST EASY', class: 'assist' },
            EASY: { id: 3, name: 'EASY', class: 'easy' },
            CLEAR: { id: 4, name: 'CLEAR', class: 'clear' },
            HARD: { id: 5, name: 'HARD', class: 'hard' },
            EXHARD: { id: 6, name: 'EX-HARD', class: 'ex-hard' },
            FC: { id: 7, name: 'FULL COMBO', class: 'fc' },
            PERFECT: { id: 8, name: 'PERFECT', class: 'perfect' },
            MAX: { id: 9, name: 'MAX', class: 'max' }
        };

        function getLamp(fileRef) {
            const data = localStorage.getItem('lamps');
            if (!data) return LAMPS.NO_PLAY;
            const lamps = JSON.parse(data);
            const lampId = lamps[fileRef];
            if (lampId === undefined) return LAMPS.NO_PLAY;
            return Object.values(LAMPS).find(l => l.id === lampId) || LAMPS.NO_PLAY;
        }

        function saveLamp(fileRef, newLamp) {
            const data = localStorage.getItem('lamps');
            const lamps = data ? JSON.parse(data) : {};
            const currentLampId = lamps[fileRef] || 0;
            if (newLamp.id > currentLampId) {
                lamps[fileRef] = newLamp.id;
                localStorage.setItem('lamps', JSON.stringify(lamps));
            }
        }

        // ----------------------------------------------------------------------------
        // ABSTRACTION LAYER (WEB VS DESKTOP)
        // ----------------------------------------------------------------------------
        const IS_DESKTOP = !!window.electronAPI;

        class DataLayer {
            constructor() {
                this.webFiles = {}; // Map<filename, File>
            }

            async readFile(ref) {
                if (IS_DESKTOP) {
                    // ref is absolute path string
                    const data = await window.electronAPI.readFile(ref);
                    // Ensure we have a Uint8Array for TextDecoder
                    let uint8;
                    if (data instanceof Uint8Array) {
                        uint8 = data;
                    } else if (data instanceof ArrayBuffer) {
                        uint8 = new Uint8Array(data);
                    } else if (data && typeof data === 'object') {
                        uint8 = new Uint8Array(Object.values(data));
                    } else {
                        throw new Error('Unexpected data format from readFile');
                    }
                    return new TextDecoder('shift-jis').decode(uint8);
                } else {
                    // ref is File object
                    const buffer = await ref.arrayBuffer();
                    return new TextDecoder('shift-jis').decode(buffer);
                }
            }

            async readAudio(ref) {
                let arrayBuffer;
                if (IS_DESKTOP) {
                    const data = await window.electronAPI.readFile(ref);
                    // Electron IPC serializes Node.js Buffer as Uint8Array or object
                    // We need to convert it to a proper ArrayBuffer for decodeAudioData
                    if (data instanceof ArrayBuffer) {
                        arrayBuffer = data;
                    } else if (data instanceof Uint8Array) {
                        // Uint8Array - get its underlying buffer (may need to slice if offset/length differ)
                        arrayBuffer = data.buffer.slice(data.byteOffset, data.byteOffset + data.byteLength);
                    } else if (data && data.buffer) {
                        // Buffer-like object with buffer property
                        arrayBuffer = data.buffer;
                    } else if (data && typeof data === 'object') {
                        // Plain object serialization - convert to Uint8Array then to ArrayBuffer
                        const uint8 = new Uint8Array(Object.values(data));
                        arrayBuffer = uint8.buffer;
                    } else {
                        throw new Error('Unexpected data format from readFile');
                    }
                } else {
                    arrayBuffer = await ref.arrayBuffer();
                }
                return await audioCtx.decodeAudioData(arrayBuffer);
            }
        }

        const dataLayer = new DataLayer();

        // ----------------------------------------------------------------------------
        // DATA STRUCTURES
        // ----------------------------------------------------------------------------

        const CHANNELS = {
            P1: {
                SCRATCH: [0x16, 0x56],
                KEY1: [0x11, 0x51], KEY2: [0x12, 0x52], KEY3: [0x13, 0x53], KEY4: [0x14, 0x54],
                KEY5: [0x15, 0x55], KEY6: [0x18, 0x58], KEY7: [0x19, 0x59]
            },
            P2: {
                SCRATCH: [0x26, 0x66],
                KEY1: [0x21, 0x61], KEY2: [0x22, 0x62], KEY3: [0x23, 0x63], KEY4: [0x24, 0x64],
                KEY5: [0x25, 0x65], KEY6: [0x28, 0x68], KEY7: [0x29, 0x69]
            },
            BGM: 0x01
        };

        const ACTIONS = {
            P1_SC_CCW: 'p1_sc_ccw', P1_SC_CW: 'p1_sc_cw',
            P1_1: 'p1_1', P1_2: 'p1_2', P1_3: 'p1_3', P1_4: 'p1_4', P1_5: 'p1_5', P1_6: 'p1_6', P1_7: 'p1_7',
            P2_SC_CCW: 'p2_sc_ccw', P2_SC_CW: 'p2_sc_cw',
            P2_1: 'p2_1', P2_2: 'p2_2', P2_3: 'p2_3', P2_4: 'p2_4', P2_5: 'p2_5', P2_6: 'p2_6', P2_7: 'p2_7',
            START: 'start', SELECT: 'select'
        };

        const DEFAULT_KEYBINDS = {
            [ACTIONS.P1_SC_CCW]: 'ShiftLeft',
            [ACTIONS.P1_SC_CW]: 'ControlLeft',
            [ACTIONS.P1_1]: 'KeyZ', [ACTIONS.P1_2]: 'KeyS', [ACTIONS.P1_3]: 'KeyX', [ACTIONS.P1_4]: 'KeyD',
            [ACTIONS.P1_5]: 'KeyC', [ACTIONS.P1_6]: 'KeyF', [ACTIONS.P1_7]: 'KeyV',

            [ACTIONS.P2_SC_CCW]: 'ShiftRight',
            [ACTIONS.P2_SC_CW]: 'ControlRight',
            [ACTIONS.P2_1]: 'KeyN', [ACTIONS.P2_2]: 'KeyJ', [ACTIONS.P2_3]: 'KeyM', [ACTIONS.P2_4]: 'KeyK',
            [ACTIONS.P2_5]: 'Comma', [ACTIONS.P2_6]: 'KeyL', [ACTIONS.P2_7]: 'Period',
            [ACTIONS.START]: 'Digit1', [ACTIONS.SELECT]: 'Digit2'
        };

        // Load keybinds from localStorage or use defaults
        function loadKeybinds() {
            const saved = localStorage.getItem('lyruanna_keybinds');
            if (saved) {
                try {
                    return { ...DEFAULT_KEYBINDS, ...JSON.parse(saved) };
                } catch (e) {
                    console.warn('Failed to parse saved keybinds, using defaults');
                }
            }
            return { ...DEFAULT_KEYBINDS };
        }

        function saveKeybinds() {
            localStorage.setItem('lyruanna_keybinds', JSON.stringify(KEYBINDS));
        }

        const KEYBINDS = loadKeybinds();

        const ACTION_TO_CHANNELS = {
            [ACTIONS.P1_SC_CCW]: CHANNELS.P1.SCRATCH,
            [ACTIONS.P1_SC_CW]: CHANNELS.P1.SCRATCH,
            [ACTIONS.P1_1]: CHANNELS.P1.KEY1, [ACTIONS.P1_2]: CHANNELS.P1.KEY2, [ACTIONS.P1_3]: CHANNELS.P1.KEY3,
            [ACTIONS.P1_4]: CHANNELS.P1.KEY4, [ACTIONS.P1_5]: CHANNELS.P1.KEY5, [ACTIONS.P1_6]: CHANNELS.P1.KEY6, [ACTIONS.P1_7]: CHANNELS.P1.KEY7,

            [ACTIONS.P2_SC_CCW]: CHANNELS.P2.SCRATCH,
            [ACTIONS.P2_SC_CW]: CHANNELS.P2.SCRATCH,
            [ACTIONS.P2_1]: CHANNELS.P2.KEY1, [ACTIONS.P2_2]: CHANNELS.P2.KEY2, [ACTIONS.P2_3]: CHANNELS.P2.KEY3,
            [ACTIONS.P2_4]: CHANNELS.P2.KEY4, [ACTIONS.P2_5]: CHANNELS.P2.KEY5, [ACTIONS.P2_6]: CHANNELS.P2.KEY6, [ACTIONS.P2_7]: CHANNELS.P2.KEY7
        };

        // TIMING WINDOWS (ms +/-)
        const JUDGE_WINDOWS = {
            0: { PG: 8, GR: 24, GD: 40, BD: 100, PR: 200 },
            1: { PG: 15, GR: 32, GD: 60, BD: 100, PR: 200 },
            2: { PG: 18, GR: 40, GD: 80, BD: 100, PR: 200 },
            3: { PG: 21, GR: 60, GD: 120, BD: 200, PR: 200 }
        };

        const STATE = {
            files: {}, // Web: File objects. Desktop: Path strings
            charts: [], // { title, artist, fileRef, ... }
            loadedSong: null,
            audioBuffers: {},
            currentFileRef: null,

            // Player Options
            speed: 4.0,
            gaugeType: 'GROOVE',
            suddenPlus: 0,
            lift: 0,
            modifier: 'OFF',
            assistMode: 'OFF', // OFF, A-SCR, EX-JUDGE, BOTH
            autoplay: false,
            showTally: true,
            difficultyFilter: 'ALL', // ALL, BEGINNER, NORMAL, HYPER, ANOTHER, LEGGENDARIA
            keyModeFilter: 'ALL', // ALL, Âçï, 5, 7, 9, Âèå, 10, 14
            hiSpeedFix: 'NONE', // NONE, MIN, MAX, AVG, CONSTANT, START, MAIN
            rangeMode: 'OFF',
            sortMode: 'DEFAULT', // DEFAULT, TITLE, LEVEL, LAMP
            startHoldTimer: null,
            isOptionsOpen: false,
            isOptionsPersistent: false,

            // Game State
            isPlaying: false,
            startTime: 0,
            score: 0,
            combo: 0,
            maxCombo: 0,
            gauge: 0,
            gaugeTick: 0,

            // Judgement Tally
            judgeCounts: { pgreat: 0, great: 0, good: 0, bad: 0, poor: 0 },
            fastSlow: { fast: 0, slow: 0 },
            comboBreaks: 0,

            // BGA
            bgaDefinitions: {},
            bgaEvents: [],
            bgaCursor: 0,
            stagefileUrl: null,
            bannerUrl: null,

            // Input
            activeActions: new Set(),

            // History for Results
            history: {
                gauge: [],
                score: []
            },
            lastNoteTime: 0,

            // System Audio & Navigation
            systemAudio: {},
            systemMapping: {},
            currentFolder: null, // name of current folder or null for root
            selectBgmSource: null,

            // Course / Autoplay
            courses: [],
            activeCourse: null,
            courseIndex: 0,
            replayFileRef: null,

            // Navigation
            selectedIndex: 0,
            currentList: [] // Array of { type: 'folder'|'chart'|'back', data: any, el: HTMLElement }
        };

        function rebuildInputMap() {
            STATE.keyCodeToAction = {};
            for (const [action, code] of Object.entries(KEYBINDS)) {
                if (!STATE.keyCodeToAction[code]) {
                    STATE.keyCodeToAction[code] = [];
                }
                STATE.keyCodeToAction[code].push(action);
            }
        }
        rebuildInputMap();

        // ----------------------------------------------------------------------------
        // PARSER
        // ----------------------------------------------------------------------------
        class BMSParser {
            static parse(text) {
                const lines = text.split(/\r?\n/);
                const headers = {};
                const bpmTable = {};
                const measureData = {}; // measure -> channel -> [data]
                let maxMeasure = 0;

                lines.forEach(line => {
                    if (!line.startsWith('#')) return;

                    // Headers & BPM Table
                    const spaceIdx = line.indexOf(' ');
                    if (spaceIdx !== -1) {
                        const key = line.substring(1, spaceIdx).toUpperCase();
                        const val = line.substring(spaceIdx + 1).trim();
                        if (key.startsWith('BPM') && key.length > 3) {
                            bpmTable[key.substring(3)] = parseFloat(val);
                        } else if (isNaN(parseInt(key.substring(0, 3)))) {
                            headers[key] = val;
                        }
                    }

                    // Channels
                    const match = line.match(/^#(\d{3})(\w{2}):(.+)$/);
                    if (match) {
                        const mIdx = parseInt(match[1]);
                        const chHex = parseInt(match[2], 16);
                        if (mIdx > maxMeasure) maxMeasure = mIdx;
                        if (!measureData[mIdx]) measureData[mIdx] = {};
                        if (!measureData[mIdx][chHex]) measureData[mIdx][chHex] = [];
                        measureData[mIdx][chHex].push(match[3]);
                    }
                });

                const PLAYABLE_CHANNELS = new Set([
                    0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x18, 0x19, // P1 Hit
                    0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x58, 0x59  // P1 LN
                ]);

                const notes = [];
                const bgm = [];
                const bgaEvents = [];
                const bpmEvents = [];

                let currentBpm = parseFloat(headers['BPM'] || 130);
                let currentTime = 0;
                let playableNoteCount = 0;

                // Process measure by measure
                for (let m = 0; m <= maxMeasure; m++) {
                    const data = measureData[m] || {};
                    const measureScaling = (data[0x02] && data[0x02][0]) ? parseFloat(data[0x02][0]) : 1.0;

                    // Collect all events in this measure to sort them by position
                    const eventsInMeasure = [];

                    for (let ch in data) {
                        const chNum = parseInt(ch);
                        if (chNum === 0x02) continue; // Skip scaling channel

                        data[ch].forEach(dataStr => {
                            const count = dataStr.length / 2;
                            for (let i = 0; i < count; i++) {
                                const val = dataStr.substr(i * 2, 2);
                                if (val === '00') continue;
                                eventsInMeasure.push({
                                    pos: i / count,
                                    ch: chNum,
                                    val: val.toUpperCase()
                                });
                            }
                        });
                    }

                    // Sort events by position in measure
                    eventsInMeasure.sort((a, b) => a.pos - b.pos);

                    // Calculate time for each event
                    let lastPos = 0;
                    eventsInMeasure.forEach(ev => {
                        const posDiff = ev.pos - lastPos;
                        // Duration of this slice: (beats in slice) * (ms per beat)
                        // One measure is 4 beats. Measure length = 4 * scaling.
                        const beatsInSlice = posDiff * 4 * measureScaling;
                        const msPerBeat = 60000 / currentBpm;
                        currentTime += beatsInSlice * msPerBeat;
                        lastPos = ev.pos;

                        const id = ev.val;
                        const chNum = ev.ch;

                        if (PLAYABLE_CHANNELS.has(chNum)) {
                            notes.push({ time: currentTime, ch: chNum, id, hit: false });
                            playableNoteCount++;
                        } else if (chNum === 0x03) {
                            currentBpm = parseInt(id, 16);
                            bpmEvents.push({ time: currentTime, bpm: currentBpm });
                        } else if (chNum === 0x08) {
                            const newBpm = bpmTable[id];
                            if (newBpm !== undefined) {
                                currentBpm = newBpm;
                                bpmEvents.push({ time: currentTime, bpm: currentBpm });
                            }
                        } else if (chNum === 0x01 || (chNum >= 0x21 && chNum <= 0x49) || (chNum >= 0x61 && chNum <= 0x69)) {
                            bgm.push({ time: currentTime, id });
                        } else if (chNum === 0x04) {
                            bgaEvents.push({ time: currentTime, id });
                        }
                    });

                    // Advance to end of measure
                    const posDiff = 1.0 - lastPos;
                    const beatsInSlice = posDiff * 4 * measureScaling;
                    currentTime += beatsInSlice * (60000 / currentBpm);
                }

                let total = parseFloat(headers['TOTAL']);
                if (isNaN(total)) total = 260;
                let rank = parseInt(headers['RANK']);
                if (isNaN(rank)) rank = 3;

                const songDuration = currentTime;
                const noteTimes = notes.map(n => n.time).sort((a, b) => a - b);
                const startNps = noteTimes.filter(t => t <= 10000).length / 10;
                const avgNps = songDuration > 0 ? (playableNoteCount / (songDuration / 1000)) : 0;

                let maxNps = 0;
                for (let i = 0; i < noteTimes.length; i++) {
                    const start = noteTimes[i];
                    const count = noteTimes.filter(t => t >= start && t < start + 1000).length;
                    if (count > maxNps) maxNps = count;
                }

                return {
                    headers,
                    notes: notes.sort((a, b) => a.time - b.time),
                    bgm: bgm.sort((a, b) => a.time - b.time),
                    bgaEvents: bgaEvents.sort((a, b) => a.time - b.time),
                    bpmEvents: bpmEvents.sort((a, b) => a.time - b.time),
                    initialBpm: parseFloat(headers['BPM'] || 130),
                    total, rank, noteCount: playableNoteCount, songDuration,
                    startNps, avgNps, maxNps
                };
            }
        }

        // ----------------------------------------------------------------------------
        // UI & LOGIC
        // ----------------------------------------------------------------------------
        const ui = {
            // Song Select
            songList: document.getElementById('song-list'),
            songCount: document.getElementById('song-count'),
            selectBg: document.getElementById('select-bg'),
            bannerArea: document.getElementById('banner-area'),
            stagefileArea: document.getElementById('stagefile-area'),
            titleMain: document.getElementById('song-title-main'),
            subtitle: document.getElementById('song-subtitle'),
            artistGenre: document.getElementById('song-artist-genre'),
            diffDisplay: document.getElementById('difficulty-display'),
            diffLevel: document.getElementById('diff-level'),
            diffTier: document.getElementById('diff-tier'),
            diffStars: document.getElementById('diff-stars'),
            songStats: document.getElementById('song-stats'),
            statBpm: document.getElementById('stat-bpm'),
            statNotes: document.getElementById('stat-notes'),
            statNpsStart: document.getElementById('stat-nps-start'),
            statNpsAvg: document.getElementById('stat-nps-avg'),
            statNpsMax: document.getElementById('stat-nps-max'),
            statRank: document.getElementById('stat-rank'),
            songMarkers: document.getElementById('song-markers'),
            btnStart: document.getElementById('btn-start'),

            // Game HUD
            score: document.getElementById('hud-score'),
            combo: document.getElementById('hud-combo'),
            comboBox: document.getElementById('hud-combo-box'),
            gaugeBar: document.getElementById('gauge-bar'),
            gaugeVal: document.getElementById('gauge-val'),
            judgeBox: document.getElementById('hud-judge-box'),
            judgeText: document.getElementById('judge-text'),
            judgeDiff: document.getElementById('judge-diff'),
            tally: document.getElementById('hud-tally'),
            tallyPg: document.getElementById('tally-pg'),
            tallyGr: document.getElementById('tally-gr'),
            tallyGd: document.getElementById('tally-gd'),
            tallyBd: document.getElementById('tally-bd'),
            tallyPr: document.getElementById('tally-pr'),
            tallyFast: document.getElementById('tally-fast'),
            tallySlow: document.getElementById('tally-slow'),
            tallyCb: document.getElementById('tally-cb'),

            // Game BGA
            gameBg: document.getElementById('game-bg'),
            gameBga: document.getElementById('game-bga'),
            bgaImg: document.getElementById('bga-img'),
            bgaVideo: document.getElementById('bga-video'),
            laneCoverTop: document.getElementById('lane-cover-top'),
            laneCoverBottom: document.getElementById('lane-cover-bottom'),

            // Modals
            modalSettings: document.getElementById('modal-settings'),
            modalOptions: document.getElementById('modal-options'),

            // Decide Screen
            screenDecide: document.getElementById('screen-decide'),
            decideTitle: document.getElementById('decide-title'),
            decideArtist: document.getElementById('decide-artist')
        };

        // --- INITIALIZATION ---
        if (IS_DESKTOP) {
            // Show custom titlebar for desktop
            document.getElementById('titlebar').style.display = 'flex';

            // Wire up window control buttons
            document.getElementById('btn-minimize').onclick = () => window.electronAPI.minimizeWindow();
            document.getElementById('btn-maximize').onclick = () => window.electronAPI.maximizeWindow();
            document.getElementById('btn-close').onclick = () => window.electronAPI.closeWindow();

            window.electronAPI.getLibrary().then(loadLibraryFromDesktop);
        }

        // Drag & Drop Course Import
        document.body.addEventListener('dragover', (e) => e.preventDefault());
        document.body.addEventListener('drop', async (e) => {
            e.preventDefault();
            const files = Array.from(e.dataTransfer.files);
            const lr2crs = files.filter(f => f.name.toLowerCase().endsWith('.lr2crs'));
            if (lr2crs.length > 0 && IS_DESKTOP) {
                for (const f of lr2crs) {
                    await window.electronAPI.importCourse(f.path);
                }
                const lib = await window.electronAPI.getLibrary();
                loadLibraryFromDesktop(lib);
            }
        });

        // --- AUTOPLAY / REPLAY BINDINGS ---
        document.getElementById('btn-autoplay').onclick = () => {
            if (!STATE.loadedSong) return;
            playSystemSound('scratch');
            STATE.autoplay = true;
            enterGame();
        };

        document.getElementById('btn-replay').onclick = () => {
            if (!STATE.loadedSong) return;
            playSystemSound('scratch');
            // Re-load the current chart to reset it, then enter game
            const currentIdx = STATE.charts.findIndex(c => c.fileRef === STATE.currentFileRef);
            if (currentIdx !== -1) {
                // Keep current autoplay state for replay? Usually yes.
                enterGame();
            }
        };

        // Button Handlers
        document.getElementById('btn-settings').onclick = () => {
            playSystemSound('o-open');
            ui.modalSettings.classList.add('open');
            renderConfig();
        };
        document.getElementById('btn-save-settings').onclick = () => {
            playSystemSound('o-close');
            ui.modalSettings.classList.remove('open');
            STATE.showTally = document.getElementById('opt-show-tally').checked;
            saveKeybinds();
            rebuildInputMap();
        };

        document.getElementById('btn-options').onclick = () => {
            playSystemSound('o-open');
            STATE.isOptionsOpen = true;
            STATE.isOptionsPersistent = true;
            ui.modalOptions.classList.add('open');
            updateOptionsUI();
            setTimeout(drawWiringLines, 50); // Delay to allow layout to render
        };
        document.getElementById('btn-save-options').onclick = () => {
            playSystemSound('o-close');
            ui.modalOptions.classList.remove('open');
            STATE.isOptionsOpen = false;
            STATE.isOptionsPersistent = false;
            renderSongList(); // Refresh in case key mode filter changed
        };

        // Filter button handlers
        document.getElementById('btn-diff-filter').onclick = () => {
            playSystemSound('difficulty');
            const filters = ['ALL', 'BEGINNER', 'NORMAL', 'HYPER', 'ANOTHER', 'LEGGENDARIA'];
            let idx = filters.indexOf(STATE.difficultyFilter);
            STATE.difficultyFilter = filters[(idx + 1) % filters.length];
            renderSongList();
        };

        document.getElementById('btn-km-filter').onclick = () => {
            playSystemSound('o-change');
            const filters = ['ALL', 'Âçï', '5', '7', '9', 'Âèå', '10', '14'];
            let idx = filters.indexOf(STATE.keyModeFilter);
            STATE.keyModeFilter = filters[(idx + 1) % filters.length];
            renderSongList();
        };

        document.getElementById('btn-sort').onclick = () => {
            playSystemSound('o-change');
            const modes = ['DEFAULT', 'TITLE', 'LEVEL', 'LAMP'];
            let idx = modes.indexOf(STATE.sortMode);
            STATE.sortMode = modes[(idx + 1) % modes.length];
            renderSongList();
        };

        // Scan Library button - Open Library Folders Modal
        document.getElementById('btn-scan-lib').onclick = async () => {
            if (IS_DESKTOP) {
                playSystemSound('o-open');
                document.getElementById('modal-folders').classList.add('open');
                await renderFolderList();
            } else {
                document.getElementById('file-picker').click();
            }
        };

        // Library Folders Modal Handlers
        const folderListEl = document.getElementById('folder-list');
        const progressSection = document.getElementById('progress-section');
        const progressBarFill = document.getElementById('progress-bar-fill');
        const progressStatus = document.getElementById('progress-status');

        async function renderFolderList() {
            const folders = await window.electronAPI.getLibraryFolders();
            folderListEl.innerHTML = '';

            if (folders.length === 0) {
                folderListEl.innerHTML = '<div class="no-folders">No folders added yet</div>';
                return;
            }

            folders.forEach(folder => {
                const div = document.createElement('div');
                div.className = 'folder-item';
                div.innerHTML = `
                    <span class="folder-path">${folder}</span>
                    <button class="folder-remove-btn" data-folder="${folder}">Remove</button>
                `;
                folderListEl.appendChild(div);
            });

            // Wire up remove buttons
            folderListEl.querySelectorAll('.folder-remove-btn').forEach(btn => {
                btn.onclick = async () => {
                    await window.electronAPI.removeLibraryFolder(btn.dataset.folder);
                    await renderFolderList();
                };
            });
        }

        document.getElementById('btn-add-folder').onclick = async () => {
            const folder = await window.electronAPI.addLibraryFolder();
            if (folder) {
                await renderFolderList();
                // Auto-rescan after adding
                await rescanAllFolders();
            }
        };

        document.getElementById('btn-rescan-all').onclick = async () => {
            await rescanAllFolders();
        };

        document.getElementById('btn-close-folders').onclick = () => {
            playSystemSound('o-close');
            document.getElementById('modal-folders').classList.remove('open');
        };

        async function rescanAllFolders() {
            progressSection.style.display = 'block';
            progressBarFill.style.width = '0%';
            progressStatus.textContent = 'Starting scan...';

            const songs = await window.electronAPI.rescanAllFolders();
            loadLibraryFromDesktop(songs);

            // Hide progress after a short delay
            setTimeout(() => {
                progressSection.style.display = 'none';
            }, 1500);
        }

        // Listen for progress updates from main process
        if (IS_DESKTOP) {
            window.electronAPI.onScanProgress((data) => {
                const percent = data.total > 0 ? (data.current / data.total * 100) : 0;
                progressBarFill.style.width = `${percent}%`;
                progressStatus.textContent = data.status;
            });
        }

        // File picker (Web mode)
        document.getElementById('file-picker').addEventListener('change', async (e) => {
            STATE.files = {};
            STATE.charts = [];
            ui.songList.innerHTML = '';

            const list = Array.from(e.target.files);
            for (let f of list) dataLayer.webFiles[f.name.toLowerCase()] = f;

            const bmsFiles = list.filter(f => f.name.match(/\.(bms|bme|bml|pms)$/i));

            for (let f of bmsFiles) {
                try {
                    const txt = await dataLayer.readFile(f);
                    const titleMatch = txt.match(/#TITLE\s+(.+)/i);
                    const artistMatch = txt.match(/#ARTIST\s+(.+)/i);
                    const levelMatch = txt.match(/#PLAYLEVEL\s+(\d+)/i);
                    const diffMatch = txt.match(/#DIFFICULTY\s+(\d+)/i);
                    
                    // Determine key mode from filename or channels
                    let keyMode = '7'; // Default
                    const fname = f.name.toLowerCase();
                    if (fname.includes('_dp') || fname.includes('14k') || fname.match(/\d{2}14/)) keyMode = '14';
                    else if (fname.includes('_10k') || fname.includes('10k')) keyMode = '10';
                    else if (fname.includes('_9k') || fname.includes('9k') || fname.endsWith('.pms')) keyMode = '9';
                    else if (fname.includes('_5k') || fname.includes('5k')) keyMode = '5';
                    else if (fname.includes('_7k') || fname.includes('7k')) keyMode = '7';
                    
                    STATE.charts.push({
                        fileRef: f,
                        title: titleMatch ? titleMatch[1].trim() : 'Unknown',
                        artist: artistMatch ? artistMatch[1].trim() : 'Unknown',
                        level: levelMatch ? parseInt(levelMatch[1]) : 0,
                        difficulty: diffMatch ? parseInt(diffMatch[1]) : 0,
                        keyMode: keyMode,
                        raw: txt
                    });
                } catch (e) { }
            }
            renderSongList();
        });

        // Start button
        ui.btnStart.onclick = () => {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            
            if (STATE.loadedSong) {
                STATE.autoplay = false;
                // Stop select loop
                if (STATE.selectBgmSource) {
                    try { STATE.selectBgmSource.stop(); } catch(e) {}
                    STATE.selectBgmSource = null;
                }
                
                playSystemSound('decide');
                
                // Set text
                ui.decideTitle.textContent = ui.titleMain.textContent;
                ui.decideArtist.textContent = STATE.loadedSong.headers['ARTIST'] || 'Unknown';
                
                // Show screen
                ui.screenDecide.style.display = 'flex';
                ui.screenDecide.classList.remove('fade-out');
                
                setTimeout(() => {
                    ui.screenDecide.classList.add('fade-out');
                    setTimeout(() => {
                        ui.screenDecide.style.display = 'none';
                        enterGame();
                    }, 1000);
                }, 4000);
            }
        };

        function loadLibraryFromDesktop(data) {
            const songs = data.songs || data; // handle both formats
            STATE.charts = songs.map(s => ({
                title: s.title,
                artist: s.artist,
                level: s.level || 0,
                difficulty: s.difficulty || 0,
                keyMode: s.keyMode || '7',
                md5: s.md5, // New
                fileRef: s.path,
                rootDir: s.rootDir,
                raw: null
            }));
            STATE.courses = data.courses || [];
            renderSongList();
        }

        function renderSongList() {
            ui.songList.innerHTML = '';
            STATE.currentList = [];

            const getCategoryName = (c) => {
                if (IS_DESKTOP) {
                    const f = c.fileRef.replace(/\\/g, '/');
                    const r = (c.rootDir || '').replace(/\\/g, '/').replace(/\/$/, '');
                    const parentDir = f.substring(0, f.lastIndexOf('/'));
                    const grandDir = parentDir.substring(0, parentDir.lastIndexOf('/'));
                    if (!r || grandDir.toLowerCase().length <= r.toLowerCase().length) {
                        const rootParts = r.split('/').filter(p => p);
                        return rootParts[rootParts.length - 1] || 'Library';
                    }
                    return grandDir.substring(grandDir.lastIndexOf('/') + 1);
                } else {
                    const parts = c.fileRef.webkitRelativePath ? c.fileRef.webkitRelativePath.split('/') : [];
                    return parts.length >= 3 ? parts[parts.length - 3] : 'Library';
                }
            };

            const addToList = (type, data, el) => {
                STATE.currentList.push({ type, data, el });
                ui.songList.appendChild(el);
            };

            // 1. Root Directory View
            if (STATE.currentFolder === null) {
                // ALWAYS show CLASS folder first
                const classDiv = document.createElement('div');
                classDiv.className = 'song-card folder folder-class';
                classDiv.innerHTML = `
                    <div class="song-card-lamp"></div>
                    <div class="song-card-content">
                        <div class="song-card-title">CLASS</div>
                        <div class="song-card-artist">COURSES</div>
                    </div>
                `;
                classDiv.onclick = () => { STATE.currentFolder = 'CLASS'; STATE.selectedIndex = 0; playSystemSound('f-open'); renderSongList(); };
                addToList('folder', { name: 'CLASS', count: STATE.courses.length, type: 'COURSE' }, classDiv);

                const folderSet = new Set();
                STATE.charts.forEach(c => folderSet.add(getCategoryName(c)));
                
                Array.from(folderSet).sort().forEach(folder => {
                    const count = STATE.charts.filter(c => getCategoryName(c) === folder).length;
                    const div = document.createElement('div');
                    div.className = 'song-card folder';
                    div.innerHTML = `
                        <div class="song-card-lamp"></div>
                        <div class="song-card-content">
                            <div class="song-card-title">${folder}</div>
                            <div class="song-card-artist">FOLDER</div>
                        </div>
                    `;
                    div.onclick = () => { STATE.currentFolder = folder; STATE.selectedIndex = 0; playSystemSound('f-open'); renderSongList(); };
                    addToList('folder', { name: folder, count: count, type: 'CATEGORY' }, div);
                });
                ui.songCount.textContent = STATE.currentList.length;
            } 
            // 2. CLASS (Courses) View
            else if (STATE.currentFolder === 'CLASS') {
                const backDiv = document.createElement('div');
                backDiv.className = 'song-card folder';
                backDiv.innerHTML = `<div class="song-card-lamp"></div><div class="song-card-content"><div class="song-card-title">.. [BACK]</div><div class="song-card-artist">RETURN TO LIBRARY</div></div>`;
                backDiv.onclick = () => { STATE.currentFolder = null; STATE.selectedIndex = 0; playSystemSound('f-close'); renderSongList(); };
                addToList('back', null, backDiv);

                STATE.courses.forEach(course => {
                    const div = document.createElement('div');
                    div.className = 'song-card folder-class';
                    div.innerHTML = `<div class="song-card-lamp"></div><div class="song-card-content"><div class="song-card-title">${course.title}</div><div class="song-card-artist">${course.hashes.length} STAGES</div></div>`;
                    div.onclick = () => {
                        STATE.activeCourse = course; STATE.courseIndex = 0;
                        const song = STATE.charts.find(c => c.md5 === course.hashes[0]);
                        if (song) loadChart(STATE.charts.indexOf(song), div);
                    };
                    addToList('course', course, div);
                });
                ui.songCount.textContent = STATE.courses.length;
            }
            // 3. Category (Songs) View
            else {
                const backDiv = document.createElement('div');
                backDiv.className = 'song-card folder';
                backDiv.innerHTML = `<div class="song-card-lamp"></div><div class="song-card-content"><div class="song-card-title">.. [BACK]</div><div class="song-card-artist">RETURN TO LIBRARY</div></div>`;
                backDiv.onclick = () => { STATE.currentFolder = null; STATE.selectedIndex = 0; playSystemSound('f-close'); renderSongList(); };
                addToList('back', null, backDiv);

                const diffTierNames = ['BEGINNER', 'NORMAL', 'HYPER', 'ANOTHER', 'LEGGENDARIA'];
                const diffIdx = diffTierNames.indexOf(STATE.difficultyFilter) + 1;
                const filtered = STATE.charts.filter(c => {
                    if (getCategoryName(c) !== STATE.currentFolder) return false;
                    if (STATE.difficultyFilter !== 'ALL' && c.difficulty !== diffIdx) return false;
                    if (STATE.keyModeFilter !== 'ALL') {
                        if (STATE.keyModeFilter === 'Âçï' && (c.keyMode === '10' || c.keyMode === '14')) return false;
                        if (STATE.keyModeFilter === 'Âèå' && (c.keyMode !== '10' && c.keyMode !== '14')) return false;
                        if (['5', '7', '9', '10', '14'].includes(STATE.keyModeFilter) && c.keyMode !== STATE.keyModeFilter) return false;
                    }
                    return true;
                });

                const sortModes = {
                    TITLE: (a, b) => a.title.localeCompare(b.title),
                    LEVEL: (a, b) => (b.level || 0) - (a.level || 0),
                    LAMP: (a, b) => {
                        const order = { 'max': 9, 'perfect': 8, 'fc': 7, 'ex-hard': 6, 'hard': 5, 'clear': 4, 'easy': 3, 'assist': 2, 'failed': 1, 'no-play': 0 };
                        return (order[getLamp(b.fileRef).class] || 0) - (order[getLamp(a.fileRef).class] || 0);
                    }
                };
                if (sortModes[STATE.sortMode]) filtered.sort(sortModes[STATE.sortMode]);

                const diffColors = ['#5ff', '#0f0', '#fa0', '#f00', '#f0f'];
                filtered.forEach(c => {
                    const lamp = getLamp(c.fileRef);
                    const diffColor = c.difficulty > 0 && c.difficulty <= 5 ? diffColors[c.difficulty - 1] : '#888';
                    const div = document.createElement('div');
                    div.className = 'song-card';
                    div.innerHTML = `<div class="song-card-lamp ${lamp.class}"></div><div class="song-card-content"><div class="song-card-title">${c.title}</div><div class="song-card-artist">${c.artist}</div></div><div class="song-card-info"><span class="song-card-level" style="background:${diffColor}; color:#000;">${c.level || '?'}</span><span class="song-card-keymode">${c.keyMode || '7'}K</span></div>`;
                    div.onclick = () => loadChart(STATE.charts.indexOf(c), div);
                    addToList('chart', c, div);
                });
                ui.songCount.textContent = filtered.length;
            }

            // Update filter displays
            document.getElementById('diff-filter').textContent = STATE.difficultyFilter;
            const kmFilterEl = document.getElementById('km-filter');
            if (kmFilterEl) kmFilterEl.textContent = STATE.keyModeFilter === 'Âçï' ? 'SINGLE' : (STATE.keyModeFilter === 'Âèå' ? 'DOUBLE' : STATE.keyModeFilter);
            const sortModeEl = document.getElementById('sort-mode');
            if (sortModeEl) sortModeEl.textContent = STATE.sortMode;

            if (STATE.selectedIndex >= STATE.currentList.length) STATE.selectedIndex = Math.max(0, STATE.currentList.length - 1);
            updateSelection();
        }

        function updateSelection() {
            STATE.currentList.forEach((item, idx) => {
                item.el.classList.toggle('focused', idx === STATE.selectedIndex);
                if (idx === STATE.selectedIndex) {
                    item.el.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    updateInfoCard(item);
                }
            });
        }

        async function updateInfoCard(item) {
            if (item.type === 'chart') {
                loadChart(STATE.charts.indexOf(item.data), item.el, true); // true = focus only
            } else if (item.type === 'folder' || item.type === 'course') {
                ui.titleMain.textContent = item.data.name || item.data.title;
                ui.subtitle.textContent = item.data.type || 'COURSE';
                ui.artistGenre.textContent = `${item.data.count || item.data.hashes.length} ITEMS`;
                ui.diffDisplay.style.display = 'none';
                ui.songStats.style.display = 'none';
                ui.songMarkers.innerHTML = '';
                ui.btnStart.disabled = true;
                ui.stagefileArea.style.backgroundImage = '';
                ui.selectBg.style.backgroundImage = '';
                ui.bannerArea.innerHTML = '<span class="banner-placeholder">Category selected</span>';
            } else if (item.type === 'back') {
                ui.titleMain.textContent = '.. [BACK]';
                ui.subtitle.textContent = 'RETURN';
                ui.artistGenre.textContent = 'Go up one level';
                ui.diffDisplay.style.display = 'none';
                ui.songStats.style.display = 'none';
                ui.btnStart.disabled = true;
            }
        }

        function updateOptionsUI() {
            if (!STATE.isOptionsOpen) return;

            // Mode
            document.querySelectorAll('#list-mode div').forEach(div => {
                div.classList.toggle('selected', div.dataset.val === STATE.keyModeFilter);
            });
            // Style
            document.querySelectorAll('#list-modifier div').forEach(div => {
                div.classList.toggle('selected', div.dataset.val === STATE.modifier);
            });
            // Gauge
            document.querySelectorAll('#list-gauge div').forEach(div => {
                div.classList.toggle('selected', div.dataset.val === STATE.gaugeType);
            });
            // Assist
            document.querySelectorAll('#list-assist div').forEach(div => {
                div.classList.toggle('selected', div.dataset.val === STATE.assistMode);
            });
            // Range
            document.querySelectorAll('#list-range div').forEach(div => {
                div.classList.toggle('selected', div.dataset.val === STATE.rangeMode);
            });
            // HS Fix
            document.querySelectorAll('#list-hsfix div').forEach(div => {
                div.classList.toggle('selected', div.dataset.val === STATE.hiSpeedFix);
            });
            // Values
            const hsValEl = document.getElementById('opt-hispeed-val');
            if (hsValEl) hsValEl.textContent = STATE.speed.toFixed(1);
            const hsFixEl = document.getElementById('opt-hsfix-val');
            if (hsFixEl) hsFixEl.textContent = `FIX: ${STATE.hiSpeedFix}`;
        }

        function drawWiringLines() {
            const svg = document.getElementById('iidx-wiring-svg');
            const guide = document.getElementById('iidx-keyboard-guide');
            const grid = document.querySelector('.iidx-options-grid');
            if (!svg || !guide || !grid) return;

            svg.innerHTML = '';
            const guideRect = guide.getBoundingClientRect();
            const gridRect = grid.getBoundingClientRect();

            // Key-to-Column mapping: 1->col1, 2->col2, 3->BATTLE(3), 4->col4, 5/7->col6, 6->col5
            const keyToCol = {
                1: 'sec-mode',
                2: 'sec-style',
                3: 'sec-battle',
                4: 'sec-gauge',
                5: 'sec-hispeed',
                6: 'sec-assist',
                7: 'sec-hispeed'
            };

            const keys = guide.querySelectorAll('.iidx-key');
            let lineIndex = 0;
            keys.forEach(key => {
                const keyNum = parseInt(key.dataset.key);
                const colId = keyToCol[keyNum];
                const colEl = document.getElementById(colId);
                if (!colEl) return;

                const keyRect = key.getBoundingClientRect();
                const colRect = colEl.getBoundingClientRect();

                // Calculate positions relative to guide container
                const x1 = keyRect.left + keyRect.width / 2 - guideRect.left;
                const y1 = keyRect.bottom - guideRect.top + 5; // Offset below key
                const x2 = colRect.left + colRect.width / 2 - guideRect.left;
                const y2 = gridRect.top - guideRect.top;

                // 90-degree turn with staggered midY to avoid overlap
                const midY = y1 + 10 + lineIndex * 6;
                lineIndex++;

                const polyline = document.createElementNS('http://www.w3.org/2000/svg', 'polyline');
                polyline.setAttribute('points', `${x1},${y1} ${x1},${midY} ${x2},${midY} ${x2},${y2}`);
                svg.appendChild(polyline);
            });
        }

        async function loadChart(idx, el, focusOnly = false) {
            if (el) {
                document.querySelectorAll('.song-card').forEach(e => e.classList.remove('active'));
                el.classList.add('active');
            }

            const c = STATE.charts[idx];
            let bmsText = c.raw;
            if (!bmsText) {
                bmsText = await dataLayer.readFile(c.fileRef);
                c.raw = bmsText;
            }

            const data = BMSParser.parse(bmsText);
            STATE.loadedSong = data;
            STATE.currentFileRef = c.fileRef;
            STATE.replayFileRef = c.fileRef;

            ui.titleMain.textContent = c.title;
            ui.subtitle.textContent = data.headers['SUBTITLE'] || '';
            const genre = data.headers['GENRE'] || '';
            ui.artistGenre.textContent = genre ? `${c.artist} | ${genre}` : c.artist;

            const level = data.headers['PLAYLEVEL'] || data.headers['DIFFICULTY'] || '?';
            const diffTier = parseInt(data.headers['DIFFICULTY']) || 2;
            const tierNames = ['BEGINNER', 'NORMAL', 'HYPER', 'ANOTHER', 'LEGGENDARIA'];
            const tierColors = ['#5ff', '#0f0', '#fa0', '#f00', '#f0f'];

            ui.diffLevel.textContent = level;
            ui.diffLevel.style.color = tierColors[Math.min(diffTier - 1, 4)] || '#fff';
            ui.diffTier.textContent = tierNames[Math.min(diffTier - 1, 4)] || 'NORMAL';
            ui.diffStars.textContent = '‚òÖ'.repeat(Math.min(parseInt(level) || 0, 12));
            ui.diffDisplay.style.display = 'flex';

            const rankName = ["VERY HARD", "HARD", "NORMAL", "EASY"][data.rank] || "EASY";
            const bpms = data.bpmEvents.map(e => e.bpm);
            bpms.push(data.initialBpm);
            const minBpm = Math.min(...bpms);
            const maxBpm = Math.max(...bpms);
            ui.statBpm.textContent = minBpm === maxBpm ? Math.round(minBpm) : `${Math.round(minBpm)} - ${Math.round(maxBpm)}`;
            ui.statNotes.textContent = data.noteCount;
            ui.statNpsAvg.textContent = data.avgNps.toFixed(1);
            ui.statNpsMax.textContent = data.maxNps;
            ui.statRank.textContent = rankName;
            ui.songStats.style.display = 'grid';

            ui.songMarkers.innerHTML = '';
            if (data.headers['LNTYPE'] || data.headers['LNOBJ']) ui.songMarkers.innerHTML += '<span class="marker marker-ln">LN</span>';
            if (data.headers['RANDOM']) ui.songMarkers.innerHTML += '<span class="marker marker-ran">RAN</span>';

            if (IS_DESKTOP && !focusOnly) {
                const stagefileUrl = await window.electronAPI.resolveImage(STATE.currentFileRef, data.headers['STAGEFILE']);
                const bannerUrl = await window.electronAPI.resolveImage(STATE.currentFileRef, data.headers['BANNER']);
                if (stagefileUrl) {
                    ui.stagefileArea.style.backgroundImage = `url('${stagefileUrl}')`;
                    ui.selectBg.style.backgroundImage = `url('${stagefileUrl}')`;
                    STATE.stagefileUrl = stagefileUrl;
                } else {
                    ui.stagefileArea.style.backgroundImage = '';
                    ui.selectBg.style.backgroundImage = '';
                    STATE.stagefileUrl = null;
                }
                if (bannerUrl) {
                    ui.bannerArea.innerHTML = `<img src="${bannerUrl}">`;
                    STATE.bannerUrl = bannerUrl;
                } else {
                    ui.bannerArea.innerHTML = '<span class="banner-placeholder">No Banner</span>';
                    STATE.bannerUrl = null;
                }
            }

            ui.btnStart.disabled = false;

            if (!focusOnly) {
                STATE.audioBuffers = {};
                STATE.bgaDefinitions = {};
                const promises = [];
                for (let k in data.headers) {
                    if (k.startsWith('WAV')) {
                        const id = k.substring(3).toUpperCase();
                        const rawFilename = data.headers[k];
                        let fileRef = IS_DESKTOP ? await window.electronAPI.resolvePath(STATE.currentFileRef, rawFilename) : dataLayer.webFiles[rawFilename.toLowerCase()];
                        if (fileRef) {
                            promises.push(dataLayer.readAudio(fileRef).then(ab => STATE.audioBuffers[id] = ab).catch(e => console.warn(`Audio ${id} error:`, e.message)));
                        }
                    }
                    if (k.startsWith('BMP') && IS_DESKTOP) {
                        const id = k.substring(3).toUpperCase();
                        const url = await window.electronAPI.resolveImage(STATE.currentFileRef, data.headers[k]);
                        if (url) STATE.bgaDefinitions[id] = { url, isVideo: /\.(mp4|webm|avi|wmv|mpg|mpeg)$/i.test(data.headers[k]) };
                    }
                }
                await Promise.all(promises);
            }
        }

        function renderConfig() {
            const p1 = document.getElementById('col-p1'); const p2 = document.getElementById('col-p2');
            p1.innerHTML = '<h4 style="margin:0 0 10px 0; color:#888;">Player 1</h4>';
            p2.innerHTML = '<h4 style="margin:0 0 10px 0; color:#888;">Player 2</h4>';
            const renderBtn = (action, label, container) => {
                const div = document.createElement('div'); div.className = 'key-row';
                div.innerHTML = `<span>${label}</span>`;
                const btn = document.createElement('button'); btn.className = 'key-btn';
                btn.textContent = KEYBINDS[action];
                btn.onclick = () => {
                    btn.textContent = '...'; btn.classList.add('listening');
                    const h = (e) => { e.preventDefault(); KEYBINDS[action] = e.code; btn.textContent = e.code; btn.classList.remove('listening'); window.removeEventListener('keydown', h); };
                    window.addEventListener('keydown', h, { once: true });
                };
                div.appendChild(btn); container.appendChild(div);
            };
            const global = document.createElement('div');
            global.style.gridColumn = 'span 2';
            global.style.borderTop = '1px solid #333';
            global.style.paddingTop = '10px';
            global.innerHTML = '<h4 style="margin:0 0 10px 0; color:#888;">Global Controls</h4>';
            const row = document.createElement('div'); row.style.display = 'flex'; row.style.gap = '20px';
            global.appendChild(row);

            renderBtn(ACTIONS.START, 'START', row);
            renderBtn(ACTIONS.SELECT, 'SELECT', row);
            p1.parentNode.appendChild(global);
            renderBtn(ACTIONS.P1_SC_CCW, "Scratch ‚Ü∂", p1);
            renderBtn(ACTIONS.P1_SC_CW, "Scratch ‚Ü∑", p1);
            for (let i = 1; i <= 7; i++) renderBtn(ACTIONS[`P1_${i}`], `Key ${i}`, p1);
            renderBtn(ACTIONS.P2_SC_CCW, "Scratch ‚Ü∂", p2);
            renderBtn(ACTIONS.P2_SC_CW, "Scratch ‚Ü∑", p2);
            for (let i = 1; i <= 7; i++) renderBtn(ACTIONS[`P2_${i}`], `Key ${i}`, p2);
        }

        // ----------------------------------------------------------------------------
        // GAME LOOP
        // ----------------------------------------------------------------------------
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');

        function enterGame() {
            document.getElementById('screen-select').style.display = 'none';
            document.getElementById('screen-game').style.display = 'block';
            resize();

            STATE.isPlaying = true;
            STATE.startTime = audioCtx.currentTime + 2.0;
            STATE.score = 0;
            STATE.combo = 0;
            STATE.maxCombo = 0;
            STATE.activeActions.clear();
            STATE.currentBpm = STATE.loadedSong.initialBpm;
            STATE.loadedSong.notes.forEach(n => n.hit = false);
            STATE.bgmCursor = 0;
            STATE.bgaCursor = 0;
            STATE.bpmCursor = 0;

            // Apply Style (Mirror/Random/R-Random/S-Random/H-Random/All-Scratch)
            if (STATE.modifier !== 'OFF') {
                const p1Keys = [0x11, 0x12, 0x13, 0x14, 0x15, 0x18, 0x19];

                if (STATE.modifier === 'MIRROR') {
                    const reversed = [...p1Keys].reverse();
                    let mapping = {};
                    p1Keys.forEach((k, i) => mapping[k] = reversed[i]);
                    STATE.loadedSong.notes.forEach(n => { if (mapping[n.ch]) n.ch = mapping[n.ch]; });
                } else if (STATE.modifier === 'RANDOM') {
                    const shuffled = [...p1Keys].sort(() => Math.random() - 0.5);
                    let mapping = {};
                    p1Keys.forEach((k, i) => mapping[k] = shuffled[i]);
                    STATE.loadedSong.notes.forEach(n => { if (mapping[n.ch]) n.ch = mapping[n.ch]; });
                } else if (STATE.modifier === 'R-RANDOM') {
                    const offset = 1 + Math.floor(Math.random() * 6);
                    let mapping = {};
                    p1Keys.forEach((k, i) => mapping[k] = p1Keys[(i + offset) % 7]);
                    STATE.loadedSong.notes.forEach(n => { if (mapping[n.ch]) n.ch = mapping[n.ch]; });
                } else if (STATE.modifier === 'S-RANDOM') {
                    STATE.loadedSong.notes.forEach(n => {
                        if (p1Keys.includes(n.ch)) n.ch = p1Keys[Math.floor(Math.random() * 7)];
                        if (p1Keys.map(k => k + 0x40).includes(n.ch)) n.ch = p1Keys[Math.floor(Math.random() * 7)] + 0x40;
                    });
                } else if (STATE.modifier === 'H-RANDOM') {
                    let lastLane = -1;
                    let lastTime = -1;
                    STATE.loadedSong.notes.forEach(n => {
                        const isLN = n.ch >= 0x51 && n.ch <= 0x59;
                        const baseKeys = isLN ? p1Keys.map(k => k + 0x40) : p1Keys;
                        if (baseKeys.includes(n.ch)) {
                            let available = [...baseKeys];
                            if (lastLane !== -1 && Math.abs(n.time - lastTime) < 50) {
                                available = available.filter(k => k !== lastLane);
                            }
                            const picked = available[Math.floor(Math.random() * available.length)];
                            n.ch = picked;
                            lastLane = picked;
                            lastTime = n.time;
                        }
                    });
                } else if (STATE.modifier === 'ALL-SCRATCH') {
                    const scratchTimes = new Set();
                    STATE.loadedSong.notes.forEach(n => {
                        if (n.ch === 0x16 || n.ch === 0x56) scratchTimes.add(Math.round(n.time));
                    });

                    const newNotes = [];
                    STATE.loadedSong.notes.forEach(n => {
                        if (p1Keys.includes(n.ch)) {
                            if (!scratchTimes.has(Math.round(n.time))) {
                                n.ch = 0x16;
                                scratchTimes.add(Math.round(n.time));
                                newNotes.push(n);
                            }
                        } else if (p1Keys.map(k => k + 0x40).includes(n.ch)) {
                            if (!scratchTimes.has(Math.round(n.time))) {
                                n.ch = 0x56;
                                scratchTimes.add(Math.round(n.time));
                                newNotes.push(n);
                            }
                        } else {
                            newNotes.push(n);
                        }
                    });
                    STATE.loadedSong.notes = newNotes.sort((a, b) => a.time - b.time);
                }
            }

            // Reset tally
            STATE.judgeCounts = { pgreat: 0, great: 0, good: 0, bad: 0, poor: 0 };
            STATE.fastSlow = { fast: 0, slow: 0 };
            STATE.comboBreaks = 0;
            updateTallyDisplay();

            // Show/hide tally based on settings
            ui.tally.classList.toggle('hidden', !STATE.showTally);

            // Set lane covers / Range
            let sudden = 0;
            let lift = 0;
            if (STATE.rangeMode === 'SUDDEN+') sudden = 30; // Default SUD+
            if (STATE.rangeMode === 'LIFT') lift = 20; // Default LIFT
            if (STATE.rangeMode === 'LIFT-SUD+') { sudden = 20; lift = 20; }

            ui.laneCoverTop.style.height = sudden + '%';
            ui.laneCoverBottom.style.height = lift + '%';

            // Set game background from stagefile
            if (STATE.stagefileUrl) {
                ui.gameBg.style.backgroundImage = `url('${STATE.stagefileUrl}')`;
            } else {
                ui.gameBg.style.backgroundImage = '';
            }

            const rawTick = STATE.loadedSong.total / Math.max(1, STATE.loadedSong.noteCount);
            STATE.gaugeTick = rawTick;

            // GAUGE INIT
            ui.gaugeBar.className = 'gauge-fill';
            if (STATE.gaugeType === 'HARD' || STATE.gaugeType === 'EXHARD') {
                STATE.gauge = 100;
                ui.gaugeBar.classList.add(STATE.gaugeType.toLowerCase());
            } else {
                STATE.gauge = 20;
                if (STATE.gaugeType === 'EASY' || STATE.gaugeType === 'ASSIST') ui.gaugeBar.classList.add('easy');
                else ui.gaugeBar.classList.add('normal');
            }
            updateGaugeDisplay();
            updateHud();

            // Reset history
            STATE.history = { gauge: [], score: [] };
            const lastNote = STATE.loadedSong.notes[STATE.loadedSong.notes.length - 1];
            STATE.lastNoteTime = lastNote ? lastNote.time : 0;

            requestAnimationFrame(loop);
        }

        function exitGame() {
            STATE.isPlaying = false;
            document.getElementById('screen-select').style.display = 'flex';
            document.getElementById('screen-game').style.display = 'none';
            
            // Restart select loop
            if (!STATE.selectBgmSource) {
                STATE.selectBgmSource = playSystemSound('select', true);
            }

            // Stop BGA video if playing
            ui.bgaVideo.pause();
            ui.bgaVideo.style.display = 'none';
            ui.bgaImg.style.display = 'none';
        }

        function updateTallyDisplay() {
            ui.tallyPg.textContent = STATE.judgeCounts.pgreat;
            ui.tallyGr.textContent = STATE.judgeCounts.great;
            ui.tallyGd.textContent = STATE.judgeCounts.good;
            ui.tallyBd.textContent = STATE.judgeCounts.bad;
            ui.tallyPr.textContent = STATE.judgeCounts.poor;
            ui.tallyFast.textContent = STATE.fastSlow.fast;
            ui.tallySlow.textContent = STATE.fastSlow.slow;
            ui.tallyCb.textContent = STATE.comboBreaks;
        }

        function playSound(id) {
            if (STATE.audioBuffers[id]) {
                const s = audioCtx.createBufferSource();
                s.buffer = STATE.audioBuffers[id];
                s.connect(audioCtx.destination);
                s.start(0);
            }
        }

        function playSystemSound(id, loop = false) {
            if (STATE.systemAudio[id]) {
                const s = audioCtx.createBufferSource();
                s.buffer = STATE.systemAudio[id];
                s.connect(audioCtx.destination);
                s.loop = loop;
                s.start(0);
                return s;
            }
            return null;
        }

        async function loadSystemSounds() {
            try {
                const mappingText = await dataLayer.readFile(IS_DESKTOP ? 'sfxmapping.txt' : 'sfxmapping.txt'); // Assuming sfxmapping.txt is in root
                const lines = mappingText.split(/\r?\n/);
                for (let line of lines) {
                    const match = line.match(/^([^:]+):\s+(.+)$/);
                    if (match) {
                        const filePath = match[1].trim();
                        const description = match[2].trim();
                        const id = filePath.split('/').pop().split('.')[0]; // e.g. 'clear'

                        try {
                            const fullPath = IS_DESKTOP ? `soundset/${filePath}` : `soundset/${filePath}`;
                            const buffer = await dataLayer.readAudio(fullPath);
                            STATE.systemAudio[id] = buffer;
                        } catch (e) {
                            console.warn("Failed to load system sound:", filePath, e);
                        }
                    }
                }
            } catch (e) {
                console.error("Failed to load sfxmapping.txt:", e);
            }
        }

        function loop() {
            if (!STATE.isPlaying) return;
            const now = (audioCtx.currentTime - STATE.startTime) * 1000;

            const bgm = STATE.loadedSong.bgm;
            while (STATE.bgmCursor < bgm.length && bgm[STATE.bgmCursor].time <= now) {
                playSound(bgm[STATE.bgmCursor].id);
                STATE.bgmCursor++;
            }

            const bpms = STATE.loadedSong.bpmEvents;
            while (STATE.bpmCursor < bpms.length && bpms[STATE.bpmCursor].time <= now) {
                STATE.currentBpm = bpms[STATE.bpmCursor].bpm;
                STATE.bpmCursor++;
                ui.statBpm.textContent = Math.round(STATE.currentBpm);
            }

            const notes = STATE.loadedSong.notes;
            let win = JUDGE_WINDOWS[STATE.loadedSong.rank] || JUDGE_WINDOWS[3];

            // Apply Extended Judge if enabled
            if (STATE.assistMode === 'EX-JUDGE' || STATE.assistMode === 'BOTH') {
                win = { PG: win.PG * 1.5, GR: win.GR * 1.5, GD: win.GD * 1.5, BD: win.BD * 1.5, PR: win.PR };
            }

            notes.forEach(n => {
                if (!n.hit) {
                    const diff = now - n.time;

                    // Autoplay: hit notes exactly at their time with PGREAT
                    if (STATE.autoplay && diff >= 0) {
                        n.hit = true;
                        playSound(n.id);
                        handleJudgment('PGREAT', 0);
                    }
                    // Normal play: miss if past BAD window
                    else if (!STATE.autoplay && diff > win.BD) {
                        n.hit = true;
                        handleJudgment('POOR', diff);
                    }
                }
            });

            render(now);

            // Sampling history for graphs (approx every 100ms)
            if (Math.floor(now / 100) > STATE.history.gauge.length) {
                STATE.history.gauge.push(STATE.gauge);
                STATE.history.score.push(STATE.score);
            }

            // End of song check
            if (now > STATE.lastNoteTime + 2000) {
                const isClear = (STATE.gaugeType === 'HARD' || STATE.gaugeType === 'EXHARD') ? (STATE.gauge > 0) : (STATE.gauge >= 80);
                showResults(isClear);
                return;
            }

            requestAnimationFrame(loop);
        }

        function render(time) {
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const wScratch = 60; const wKey = 40;
            const p1Total = wScratch + (wKey * 7);
            const startX = 30; // Left position instead of centered
            const hitY = canvas.height - 100;
            // Scroll speed scales with BPM to keep distance between beats constant
            // Reference BPM 150 for the HI-SPEED multiplier
            // Base speed increased by 2.5x (0.15 -> 0.375)
            const speed = (STATE.speed * 0.375) * (STATE.currentBpm / 150);

            ctx.save();
            ctx.translate(startX, 0);

            const drawLane = (actions, x, w, isBlack, isBlue, isScratch) => {
                const actionList = Array.isArray(actions) ? actions : [actions];
                const active = actionList.some(a => STATE.activeActions.has(a));
                if (isScratch) ctx.fillStyle = active ? '#500' : '#200';
                else if (isBlue) ctx.fillStyle = active ? '#003355' : '#000510';
                else ctx.fillStyle = active ? '#333' : '#111';
                ctx.fillRect(x, 0, w, canvas.height);
                ctx.strokeStyle = '#333'; ctx.strokeRect(x, 0, w, canvas.height);
                if (active) {
                    ctx.fillStyle = 'rgba(255,255,255,0.1)'; ctx.fillRect(x, 0, w, canvas.height);
                    const g = ctx.createLinearGradient(0, canvas.height, 0, canvas.height - 300);
                    g.addColorStop(0, 'rgba(255,255,255,0.4)'); g.addColorStop(1, 'rgba(0,0,0,0)');
                    ctx.fillStyle = g; ctx.fillRect(x, canvas.height - 300, w, 300);
                }
            };

            drawLane([ACTIONS.P1_SC_CCW, ACTIONS.P1_SC_CW], 0, wScratch, false, false, true);
            let curX = wScratch;
            for (let i = 1; i <= 7; i++) {
                const isBlue = (i === 2 || i === 4 || i === 6);
                drawLane(ACTIONS[`P1_${i}`], curX, wKey, !isBlue, isBlue);
                curX += wKey;
            }

            ctx.fillStyle = '#ff0055';
            ctx.fillRect(0, hitY, p1Total, 15);

            STATE.loadedSong.notes.forEach(n => {
                if (n.hit) return;
                let x = -1, w = wKey, isSc = false, isBlue = false;
                const ch = n.ch;
                if (CHANNELS.P1.SCRATCH.includes(ch)) { x = 0; w = wScratch; isSc = true; }
                else if (CHANNELS.P1.KEY1.includes(ch)) { x = wScratch; }
                else if (CHANNELS.P1.KEY2.includes(ch)) { x = wScratch + wKey; isBlue = true; }
                else if (CHANNELS.P1.KEY3.includes(ch)) { x = wScratch + wKey * 2; }
                else if (CHANNELS.P1.KEY4.includes(ch)) { x = wScratch + wKey * 3; isBlue = true; }
                else if (CHANNELS.P1.KEY5.includes(ch)) { x = wScratch + wKey * 4; }
                else if (CHANNELS.P1.KEY6.includes(ch)) { x = wScratch + wKey * 5; isBlue = true; }
                else if (CHANNELS.P1.KEY7.includes(ch)) { x = wScratch + wKey * 6; }

                if (x === -1) return;

                const dist = (n.time - time) * speed;
                const y = hitY - dist;

                if (y < -50 || y > canvas.height + 50) return;

                if (isSc) ctx.fillStyle = '#f00';
                else if (isBlue) ctx.fillStyle = '#0cf';
                else ctx.fillStyle = '#fff';

                ctx.fillRect(x + 1, y, w - 2, 15);
            });
            ctx.restore();
        }

        // ----------------------------------------------------------------------------
        // JUDGEMENT SYSTEM
        // ----------------------------------------------------------------------------
        function handleJudgment(result, diffMs, isEmptyPoor = false) {
            // Scoring
            let scoreAdd = 0;
            if (result === 'PGREAT') scoreAdd = 2;
            else if (result === 'GREAT') scoreAdd = 1;
            STATE.score += scoreAdd;

            // Combo
            if (!isEmptyPoor) {
                if (result === 'BAD' || result === 'POOR') {
                    if (STATE.combo > 0) {
                        STATE.comboBreaks++;
                    }
                    STATE.combo = 0;
                } else {
                    STATE.combo++;
                    if (STATE.combo > STATE.maxCombo) STATE.maxCombo = STATE.combo;

                    // Track fast/slow (only for PGREAT/GREAT/GOOD)
                    if (diffMs < 0) STATE.fastSlow.fast++;
                    else if (diffMs > 0) STATE.fastSlow.slow++;
                }

                // Track judgement counts
                if (result === 'PGREAT') STATE.judgeCounts.pgreat++;
                else if (result === 'GREAT') STATE.judgeCounts.great++;
                else if (result === 'GOOD') STATE.judgeCounts.good++;
                else if (result === 'BAD') STATE.judgeCounts.bad++;
                else if (result === 'POOR') STATE.judgeCounts.poor++;

                updateTallyDisplay();
            }

            // Gauge Logic
            let damage = 0;
            let recover = 0;

            if (STATE.gaugeType === 'EXHARD') {
                // EX-HARD
                if (isEmptyPoor) damage = 8.0;
                else if (result === 'PGREAT') recover = 0.1;
                else if (result === 'GREAT') recover = 0.1;
                else if (result === 'GOOD') recover = 0.1;
                else if (result === 'BAD') damage = 10.0;
                else if (result === 'POOR') damage = 18.0;

                STATE.gauge = STATE.gauge + recover - damage;
            }
            else if (STATE.gaugeType === 'HARD') {
                // HARD
                if (isEmptyPoor) damage = 2.0;
                else if (result === 'PGREAT') recover = 0.1;
                else if (result === 'GREAT') recover = 0.1;
                else if (result === 'GOOD') recover = 0.1;
                else if (result === 'BAD') damage = 6.0;
                else if (result === 'POOR') damage = 10.0;

                // LR2 Hard Gauge Adjustment
                if (damage > 0 && STATE.gauge <= 30) {
                    damage *= 0.6;
                }

                STATE.gauge = STATE.gauge + recover - damage;
            }
            else if (STATE.gaugeType === 'EASY') {
                // EASY
                if (isEmptyPoor) damage = 1.6;
                else if (result === 'PGREAT' || result === 'GREAT') recover = STATE.gaugeTick;
                else if (result === 'GOOD') recover = (STATE.gaugeTick / 2);
                else if (result === 'BAD') damage = 1.6;
                else if (result === 'POOR') damage = 4.8;

                STATE.gauge = STATE.gauge + recover - damage;
            }
            else {
                // GROOVE (Normal)
                if (isEmptyPoor) damage = 2.0;
                else if (result === 'PGREAT' || result === 'GREAT') recover = STATE.gaugeTick;
                else if (result === 'GOOD') recover = (STATE.gaugeTick / 2);
                else if (result === 'BAD') damage = 2.0;
                else if (result === 'POOR') damage = 6.0;

                STATE.gauge = STATE.gauge + recover - damage;
            }

            // Fail Check for Hard/ExHard
            if ((STATE.gaugeType === 'HARD' || STATE.gaugeType === 'EXHARD') && STATE.gauge <= 0) {
                STATE.gauge = 0;
                playSystemSound('playstop');
                showResults(false);
                return;
            }

            // Clamp
            if (STATE.gauge > 100) STATE.gauge = 100;
            if (STATE.gaugeType !== 'HARD' && STATE.gaugeType !== 'EXHARD' && STATE.gauge < 2) STATE.gauge = 2;

            updateGaugeDisplay();
            updateHud();

            showJudge(result, diffMs);
        }

        function updateGaugeDisplay() {
            ui.gaugeBar.style.width = `${STATE.gauge}%`;
            ui.gaugeVal.textContent = `${Math.floor(STATE.gauge)}%`;

            if (STATE.gaugeType !== 'HARD' && STATE.gaugeType !== 'EXHARD') {
                if (STATE.gauge >= 80) ui.gaugeBar.classList.add('cleared');
                else ui.gaugeBar.classList.remove('cleared');
            }
        }

        function showJudge(text, diff) {
            ui.judgeText.textContent = text;
            ui.judgeText.className = 'judge-text ' + text.toLowerCase();

            const sign = diff > 0 ? '+' : '';
            ui.judgeDiff.textContent = (text !== 'POOR' && diff !== 0) ? `${sign}${Math.floor(diff)}ms` : '';

            ui.judgeBox.classList.remove('show');
            void ui.judgeBox.offsetWidth;
            ui.judgeBox.classList.add('show');
        }

        function updateHud() {
            ui.score.textContent = STATE.score;
            ui.combo.textContent = STATE.combo;
            if (STATE.combo > 2) ui.comboBox.classList.add('show'); else ui.comboBox.classList.remove('show');
        }

        // ----------------------------------------------------------------------------
        // RESULTS SYSTEM
        // ----------------------------------------------------------------------------
        function showResults(isClear) {
            STATE.isPlaying = false;
            
            if (isClear) playSystemSound('clear');
            else playSystemSound('fail');

            document.getElementById('screen-game').style.display = 'none';
            document.getElementById('screen-results').style.display = 'flex';

            const maxEx = STATE.loadedSong.notes.length * 2;
            const percent = (STATE.score / Math.max(1, maxEx)) * 100;

            // UI Text
            document.getElementById('res-status').textContent = isClear ? 'CLEARED' : 'FAILED';
            document.getElementById('res-status').style.color = isClear ? 'var(--accent)' : '#f44';
            document.getElementById('res-song-title').textContent = STATE.loadedSong.headers['TITLE'] || 'Unknown';

            document.getElementById('res-rank').textContent = calculateRank(percent);
            document.getElementById('res-rank').style.color = getRankColor(calculateRank(percent));

            const nextRank = getNextRankInfo(percent, maxEx);
            document.getElementById('res-rank-next').textContent = nextRank ? `NEXT RANK: ${nextRank.name} (+${nextRank.diff})` : 'MAX RANK ACHIEVED';

            // Tally
            document.getElementById('res-pg').textContent = STATE.judgeCounts.pgreat;
            document.getElementById('res-gr').textContent = STATE.judgeCounts.great;
            document.getElementById('res-gd').textContent = STATE.judgeCounts.good;
            document.getElementById('res-bd').textContent = STATE.judgeCounts.bad;
            document.getElementById('res-pr').textContent = STATE.judgeCounts.poor;
            document.getElementById('res-fast').textContent = STATE.fastSlow.fast;
            document.getElementById('res-slow').textContent = STATE.fastSlow.slow;
            document.getElementById('res-max-combo').textContent = STATE.maxCombo;

            // Score
            document.getElementById('res-ex-score').textContent = STATE.score;
            document.getElementById('res-percent').textContent = percent.toFixed(2) + '%';

            // Lamps
            const lamp = determineClearLamp(isClear);
            saveLamp(STATE.currentFileRef, lamp);
            const lampEl = document.getElementById('res-lamp');
            lampEl.className = 'lamp ' + lamp.class;
            document.getElementById('res-lamp-text').textContent = lamp.name;
            document.getElementById('res-lamp-text').style.color = getComputedStyle(lampEl).backgroundColor;

            // Update song list UI if needed (proactive)
            renderSongList();

            // Graphs
            drawGraph('graph-gauge', STATE.history.gauge, [2, 100], isClear ? '#00ff9d' : '#ff4444');
            drawGraph('graph-score', STATE.history.score, [0, maxEx], '#55aaff');

            // Global listener to exit results
            const returnHandler = (e) => {
                document.getElementById('screen-results').style.display = 'none';
                
                if (STATE.activeCourse) {
                    STATE.courseIndex++;
                    if (STATE.courseIndex < STATE.activeCourse.hashes.length) {
                        const nextHash = STATE.activeCourse.hashes[STATE.courseIndex];
                        const song = STATE.charts.find(c => c.md5 === nextHash);
                        if (song) {
                            // Find card element if possible (or just use null)
                            loadChart(STATE.charts.indexOf(song), { classList: { add:()=>{} }, classList: { remove:()=>{} }, style: {} });
                            enterGame();
                        } else {
                            alert('Next song in course not found! Hash: ' + nextHash);
                            STATE.activeCourse = null;
                            exitToSelect();
                        }
                    } else {
                        // Course Clear!
                        STATE.activeCourse = null;
                        exitToSelect();
                    }
                } else {
                    exitToSelect();
                }
                
                window.removeEventListener('keydown', returnHandler);
            };

            function exitToSelect() {
                document.getElementById('screen-select').style.display = 'flex';
                if (!STATE.selectBgmSource) {
                    STATE.selectBgmSource = playSystemSound('select', true);
                }
            }

            setTimeout(() => {
                window.addEventListener('keydown', returnHandler);
            }, 500);
        }

        function calculateRank(p) {
            if (p >= 88.88) return 'AAA'; // 8/9
            if (p >= 77.77) return 'AA';  // 7/9
            if (p >= 66.66) return 'A';   // 6/9
            if (p >= 55.55) return 'B';   // 5/9
            if (p >= 44.44) return 'C';   // 4/9
            if (p >= 33.33) return 'D';   // 3/9
            if (p >= 22.22) return 'E';   // 2/9
            return 'F';
        }

        function getRankColor(rank) {
            const colors = { 'AAA': '#fff700', 'AA': '#c0c0c0', 'A': '#cd7f32', 'B': '#00ff00', 'C': '#0000ff', 'D': '#ff00ff', 'E': '#ff0000', 'F': '#888' };
            return colors[rank] || '#fff';
        }

        function getNextRankInfo(p, maxEx) {
            // Standard BMS rank thresholds are exactly these ninths:
            const exactThresholds = [
                { name: 'E', ratio: 2 / 9 },
                { name: 'D', ratio: 3 / 9 },
                { name: 'C', ratio: 4 / 9 },
                { name: 'B', ratio: 5 / 9 },
                { name: 'A', ratio: 6 / 9 },
                { name: 'AA', ratio: 7 / 9 },
                { name: 'AAA', ratio: 8 / 9 }
            ];

            for (let t of exactThresholds) {
                const targetScore = Math.ceil(maxEx * t.ratio);
                if (STATE.score < targetScore) {
                    const diff = targetScore - STATE.score;
                    return { name: t.name, diff: diff };
                }
            }
            // If we are AAA, show MAX diff
            if (calculateRank(p) === 'AAA') {
                const diff = maxEx - STATE.score;
                if (diff > 0) return { name: 'MAX', diff: diff };
            }
            return null;
        }

        function determineClearLamp(isClear) {
            const maxEx = STATE.loadedSong.notes.length * 2;
            const isPerfect = (STATE.judgeCounts.pgreat === STATE.loadedSong.notes.length); // All PGREAT
            const isNoBadPoor = (STATE.judgeCounts.bad === 0 && STATE.judgeCounts.poor === 0);
            const isFC = (STATE.comboBreaks === 0 && isNoBadPoor); // Full Combo: no combo breaks AND no bad/poor

            // Correction: Perfect is 100% EX score. 
            // The user says: Perfect (only PGreat and Great) -> MAX (100%)
            // So: Perfect is FC + only PG/GR. MAX is all PG.

            const onlyPGGR = (STATE.judgeCounts.good === 0 && STATE.judgeCounts.bad === 0 && STATE.judgeCounts.poor === 0);
            const isMax = (STATE.score === maxEx);

            if (isMax) return LAMPS.MAX;
            if (onlyPGGR && isFC) return LAMPS.PERFECT;
            if (isFC) return LAMPS.FC;

            if (!isClear) return LAMPS.FAILED;

            // Gauge based clears
            if (STATE.gaugeType === 'EXHARD') return LAMPS.EXHARD;
            if (STATE.gaugeType === 'HARD') return LAMPS.HARD;
            if (STATE.gaugeType === 'EASY' || STATE.gaugeType === 'ASSIST') {
                if (STATE.gaugeType === 'ASSIST') return LAMPS.ASSIST;
                return LAMPS.EASY;
            }
            return LAMPS.CLEAR;
        }

        function drawGraph(canvasId, data, range, color) {
            const canvas = document.getElementById(canvasId);
            const ctx = canvas.getContext('2d');
            const w = canvas.width = canvas.clientWidth;
            const h = canvas.height = canvas.clientHeight;

            ctx.clearRect(0, 0, w, h);

            // Draw grid
            ctx.strokeStyle = '#222';
            ctx.lineWidth = 1;
            for (let i = 1; i < 4; i++) {
                const y = (h / 4) * i;
                ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(w, y); ctx.stroke();
            }

            if (data.length < 2) return;

            const [min, max] = range;
            const stepX = w / (data.length - 1);

            ctx.beginPath();
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            ctx.lineJoin = 'round';

            for (let i = 0; i < data.length; i++) {
                const val = (data[i] - min) / (max - min);
                const x = i * stepX;
                const y = h - (val * h);
                if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
            }
            ctx.stroke();

            // Fill area
            ctx.lineTo(w, h);
            ctx.lineTo(0, h);
            ctx.closePath();
            const grad = ctx.createLinearGradient(0, 0, 0, h);

            let colorStart = color;
            let colorEnd = 'rgba(0,0,0,0)';

            if (color.startsWith('#')) {
                colorStart = color + '66'; // 40% alpha
                colorEnd = color + '00';   // 0% alpha
            } else if (color.startsWith('rgb')) {
                colorStart = color.replace('rgb', 'rgba').replace(')', ', 0.4)');
                colorEnd = color.replace('rgb', 'rgba').replace(')', ', 0)');
            }

            grad.addColorStop(0, colorStart);
            grad.addColorStop(1, colorEnd);
            ctx.fillStyle = grad;
            ctx.fill();
        }

        // ----------------------------------------------------------------------------
        // INPUT
        // ----------------------------------------------------------------------------
        window.addEventListener('keydown', e => {
            // Handle Escape key first (before actions check)
            if (e.code === 'Escape' && STATE.isPlaying) { exitGame(); return; }

            const actions = STATE.keyCodeToAction[e.code];
            if (!actions) return;

            // Immediate START open (if Settings not open)
            if (actions.includes(ACTIONS.START) && !STATE.isPlaying) {
                if (ui.modalSettings.classList.contains('open')) return; // Block if Settings is open
                if (!STATE.isOptionsOpen) {
                    STATE.isOptionsOpen = true;
                    STATE.startOpenedOptions = true; // Track that START was used to open options
                    ui.modalOptions.classList.add('open');
                    updateOptionsUI();
                    drawWiringLines();
                }
            }

            // Options menu navigation
            if (STATE.isOptionsOpen) {
                e.preventDefault();
                actions.forEach(action => {
                    STATE.activeActions.add(action);

                    const has5 = STATE.activeActions.has(ACTIONS.P1_5);
                    const has7 = STATE.activeActions.has(ACTIONS.P1_7);
                    const has6 = STATE.activeActions.has(ACTIONS.P1_6);

                    // Key 1: Mode Cycle
                    if (action === ACTIONS.P1_1) {
                        const modes = ['ALL', 'Âçï', '5', '7', '9', 'Âèå', '10', '14'];
                        let idx = modes.indexOf(STATE.keyModeFilter);
                        STATE.keyModeFilter = modes[(idx + 1) % modes.length];
                    }
                    // Key 2: Style Cycle
                    if (action === ACTIONS.P1_2) {
                        const styles = ['OFF', 'MIRROR', 'RANDOM', 'S-RANDOM', 'H-RANDOM', 'R-RANDOM', 'ALL-SCRATCH'];
                        let idx = styles.indexOf(STATE.modifier);
                        STATE.modifier = styles[(idx + 1) % styles.length];
                    }
                    // Key 3: Battle Placeholder
                    if (action === ACTIONS.P1_3) { /* placeholder */ }
                    // Key 4: Gauge Cycle
                    if (action === ACTIONS.P1_4) {
                        const gauges = ['GROOVE', 'EASY', 'HARD', 'EXHARD', 'ASSIST'];
                        let idx = gauges.indexOf(STATE.gaugeType);
                        STATE.gaugeType = gauges[(idx + 1) % gauges.length];
                    }
                    // Key 5/7: HS / Fix
                    if (action === ACTIONS.P1_5) {
                        if (has7) {
                            const fixes = ['NONE', 'MIN', 'MAX', 'AVG', 'CONSTANT'];
                            let idx = fixes.indexOf(STATE.hiSpeedFix);
                            STATE.hiSpeedFix = fixes[(idx + 1) % fixes.length];
                        } else {
                            STATE.speed = Math.max(0.5, STATE.speed - 0.5);
                        }
                    }
                    if (action === ACTIONS.P1_7) {
                        if (has5) {
                            const fixes = ['NONE', 'MIN', 'MAX', 'AVG', 'CONSTANT'];
                            let idx = fixes.indexOf(STATE.hiSpeedFix);
                            STATE.hiSpeedFix = fixes[(idx + 1) % fixes.length];
                        } else if (has6) {
                            const ranges = ['OFF', 'SUDDEN+', 'LIFT', 'LIFT-SUD+'];
                            let idx = ranges.indexOf(STATE.rangeMode);
                            STATE.rangeMode = ranges[(idx + 1) % ranges.length];
                        } else {
                            STATE.speed = Math.min(10, STATE.speed + 0.5);
                        }
                    }
                    // Key 6: Assist / Range
                    if (action === ACTIONS.P1_6) {
                        if (has7) {
                            const ranges = ['OFF', 'SUDDEN+', 'LIFT', 'LIFT-SUD+'];
                            let idx = ranges.indexOf(STATE.rangeMode);
                            STATE.rangeMode = ranges[(idx + 1) % ranges.length];
                        } else {
                            const assists = ['OFF', 'A-SCR', 'EX-JUDGE', 'BOTH'];
                            let idx = assists.indexOf(STATE.assistMode);
                            STATE.assistMode = assists[(idx + 1) % assists.length];
                        }
                    }

                    // Play change sound for relevant keys
                    if ([ACTIONS.P1_1, ACTIONS.P1_2, ACTIONS.P1_4, ACTIONS.P1_5, ACTIONS.P1_6, ACTIONS.P1_7].includes(action)) {
                        playSystemSound('o-change');
                    }
                });
                updateOptionsUI();
                return;
            }

            if (ui.modalSettings.classList.contains('open')) {
                return;
            }

            e.preventDefault();
            actions.forEach(action => {
                STATE.activeActions.add(action);

                if (!STATE.isPlaying && !STATE.isOptionsOpen) {
                    // SCRATCH NAVIGATION
                    if (action === ACTIONS.P1_SC_CCW) {
                        STATE.selectedIndex = (STATE.selectedIndex - 1 + STATE.currentList.length) % STATE.currentList.length;
                        playSystemSound('scratch');
                        updateSelection();
                        return;
                    }
                    if (action === ACTIONS.P1_SC_CW) {
                        STATE.selectedIndex = (STATE.selectedIndex + 1) % STATE.currentList.length;
                        playSystemSound('scratch');
                        updateSelection();
                        return;
                    }

                    // FOLDER CONTROLS (NUMERICAL)
                    const item = STATE.currentList[STATE.selectedIndex];
                    const isOpenKey = [ACTIONS.P1_1, ACTIONS.P1_3, ACTIONS.P1_5, ACTIONS.P1_7].includes(action);
                    const isCloseKey = [ACTIONS.P1_2, ACTIONS.P1_4, ACTIONS.P1_6].includes(action);

                    if (isOpenKey) {
                        if (item.type === 'back') {
                             STATE.currentFolder = null; STATE.selectedIndex = 0; playSystemSound('f-close'); renderSongList();
                        } else if (item.type === 'folder' || item.type === 'course') {
                            item.el.click();
                        } else if (item.type === 'chart') {
                            if (ui.btnStart.disabled === false) ui.btnStart.click();
                        }
                        return;
                    }

                    if (isCloseKey && STATE.currentFolder !== null) {
                        STATE.currentFolder = null; STATE.selectedIndex = 0; playSystemSound('f-close'); renderSongList();
                        return;
                    }
                }

                // SELECT KEY CYCLE LOGIC
                if (action === ACTIONS.SELECT && !STATE.isPlaying) {
                    const filters = ['ALL', 'BEGINNER', 'NORMAL', 'HYPER', 'ANOTHER', 'LEGGENDARIA'];
                    let idx = filters.indexOf(STATE.difficultyFilter);
                    STATE.difficultyFilter = filters[(idx + 1) % filters.length];
                    renderSongList();
                    return;
                }

                if (!STATE.isPlaying || e.repeat) return;

                const targets = ACTION_TO_CHANNELS[action];
                if (!targets) return;

                const now = (audioCtx.currentTime - STATE.startTime) * 1000;
                let win = JUDGE_WINDOWS[STATE.loadedSong.rank] || JUDGE_WINDOWS[3];
                if (STATE.assistMode === 'EX-JUDGE' || STATE.assistMode === 'BOTH') {
                    win = { PG: win.PG * 1.5, GR: win.GR * 1.5, GD: win.GD * 1.5, BD: win.BD * 1.5, PR: win.PR };
                }

                const noteIdx = STATE.loadedSong.notes.findIndex(n =>
                    !n.hit && targets.includes(n.ch) && Math.abs(now - n.time) <= win.BD
                );

                if (noteIdx !== -1) {
                    const note = STATE.loadedSong.notes[noteIdx];
                    note.hit = true;
                    playSound(note.id);
                    const diff = now - note.time;
                    const absDiff = Math.abs(diff);
                    let res = 'BAD';
                    if (absDiff <= win.PG) res = 'PGREAT';
                    else if (absDiff <= win.GR) res = 'GREAT';
                    else if (absDiff <= win.GD) res = 'GOOD';
                    handleJudgment(res, diff);
                } else {
                    const upcomingNoteIdx = STATE.loadedSong.notes.findIndex(n =>
                        !n.hit && targets.includes(n.ch) && (n.time - now) > win.BD && (n.time - now) <= 1000
                    );
                    if (upcomingNoteIdx !== -1) {
                        handleJudgment('POOR', 0, true);
                    }
                }
            });
        });

        window.addEventListener('keyup', e => {
            const actions = STATE.keyCodeToAction[e.code];
            if (!actions) return;

            actions.forEach(action => {
                STATE.activeActions.delete(action);

                if (action === ACTIONS.START) {
                    const optionsWereOpen = STATE.isOptionsOpen;
                    // Close options on release (if held or if we're tapping to close)
                    if (STATE.isOptionsOpen && (!STATE.isOptionsPersistent || optionsWereOpen)) {
                        ui.modalOptions.classList.remove('open');
                        STATE.isOptionsOpen = false;
                        renderSongList();
                    }
                    // Reset persistence
                    STATE.isOptionsPersistent = false;

                    // Reset the flag
                    STATE.startOpenedOptions = false;
                }

                // White keys to start game
                if ([ACTIONS.P1_1, ACTIONS.P1_3, ACTIONS.P1_5, ACTIONS.P1_7,
                ACTIONS.P2_1, ACTIONS.P2_3, ACTIONS.P2_5, ACTIONS.P2_7].includes(action)) {
                    if (!STATE.isPlaying && !STATE.isOptionsOpen) {
                        if (ui.btnStart.disabled === false) ui.btnStart.click();
                    }
                }
            });
        });

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resize);

        // INITIALIZATION
        (async () => {
            await loadSystemSounds();
            
            // Resume/Start BGM on first interaction
            const startBgm = () => {
                if (audioCtx.state === 'suspended') audioCtx.resume();
                if (!STATE.selectBgmSource) {
                    STATE.selectBgmSource = playSystemSound('select', true);
                }
                window.removeEventListener('keydown', startBgm);
                window.removeEventListener('mousedown', startBgm);
            };
            window.addEventListener('keydown', startBgm);
            window.addEventListener('mousedown', startBgm);

            if (IS_DESKTOP) {
                // Auto-rescan library on startup
                console.log("Startup: Rescanning library...");
                await rescanAllFolders();
            }
        })();

    </script>
</body>

</html>